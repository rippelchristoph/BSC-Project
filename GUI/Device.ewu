$version 6.60

$rect <50,250,250,290>
inline I2CHeader
{
  #include <unistd.h>				//Needed for I2C port
  #include <fcntl.h>				//Needed for I2C port
  #include <sys/ioctl.h>			//Needed for I2C port
  #include <linux/i2c-dev.h>		//Needed for I2C port
  #include <stdio.h>
  #include <time.h>
}

$rect <60,70,260,110>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <920,80,1120,120>
  property int32 NuOfCircuits = 6;

  $rect <1120,80,1320,120>
  onset NuOfCircuits
  {
    // The property doesn't change -> nothing to do.
    if ( pure NuOfCircuits == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure NuOfCircuits = value;
    trace "NumberOfCircuits:"+string(NuOfCircuits);


    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^NuOfCircuits;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <720,80,920,120>
  $output true
  method void UpdateNuOfCircuits( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure NuOfCircuits )
    {
      // Remember the new value in the internal memory of the property.
      pure NuOfCircuits = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^NuOfCircuits;
    }
  }

  $rect <240,80,440,120>
  property bool NewWell = false;

  $rect <440,80,640,120>
  onset NewWell
  {
    // The property doesn't change -> nothing to do.
    if ( pure NewWell == value )
      return;



    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    trace "NewWell";

    // Notify all associated property observers.
    notifyobservers ^NewWell;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <40,80,240,120>
  $output true
  method void UpdateNewWell( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure NewWell )
    {
     
      notifyobservers ^NewWell;
    }
  }

  // intervall in seconds; circuitNumber from 1 to 6
  $rect <40,180,240,220>
  method void StartSampling( arg int32 aIntervall, arg int32 aCircuitNumber )
  {
    $if $prototyper


    aIntervall;
    aCircuitNumber;


                                                        
    $endif

    trace "StartSampling - Intervall:"+string(aIntervall)+" CircuitNumber:"+string(aCircuitNumber);

    $if !$prototyper
     
    if(aCircuitNumber<0||aCircuitNumber>5){
      trace "ERROR: Wrong CircuitNumber";
      return;
    }if(aIntervall<=0){
      trace "ERROR: Wrong Intervall";
      return;
    }

      
     
    $endif
  }

  $rect <240,280,440,320>
  object Core::SystemEvent SampleCollectedEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,280,240,320>
  $output true
  method void onSampleCollected( arg point aWellIndex, arg int32 aCircuitNumber, arg string aTime )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.


    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
    trace "SampleCollected - X:"+string(aWellIndex.x)+"X:"+string(aWellIndex.y)+" CircuitNumber:"+string(aCircuitNumber)+" Time:"+aTime;


    var Device::SampleCollectedContext context = new Device::SampleCollectedContext;
    context.WellIndex = aWellIndex;
    context.CircuitNumber = aCircuitNumber;
    context.Time = aTime;
    SampleCollectedEvent.Trigger( context, false );
  }

  $rect <240,330,440,370>
  object Core::SystemEvent RemainingTimeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,330,240,370>
  $output true
  method void onRemainingTime( arg int32 aCircuitNumber, arg int32 aRemainingTime )
  {
    var Device::RemainingTimeContext context = new Device::RemainingTimeContext;
    if(aCircuitNumber>5||aCircuitNumber<0){
      trace "ERROR: Wrong Circuit Number";
      return;
    }

    context.CircuitNumber=aCircuitNumber;
    context.RemainingTime=aRemainingTime;
    RemainingTimeEvent.Trigger( context, false );
  }

  $rect <40,230,240,270>
  method void StopSampling( arg int32 aCircuitNumber )
  {
    // The following code is used during prototyping only. It simply returns
    // a dummy value. No device specific API is used during prototyping.
    $if $prototyper
    $endif
    trace "StopSampling - CircuitNumber:"+string(aCircuitNumber);
    $if !$prototyper

    if(aCircuitNumber<0||aCircuitNumber>5){
      trace "ERROR: Wrong CircuitNumber";
      return;
    }
     
    $endif
  }

  $rect <720,120,920,160>
  method void SetBLPosition( arg int32 aX, arg int32 aY, arg int32 aZ )
  {
    // The following code is used during prototyping only. It simply returns
    // a dummy value. No device specific API is used during prototyping.
    $if $prototyper
    $endif

    trace "BLPostition: X:"+string(aX)+" Y:"+string(aY)+" Z:"+string(aZ);

    $if !$prototyper
     
    $endif
  }

  $rect <720,160,920,200>
  method void SetTRPosition( arg int32 aX, arg int32 aY, arg int32 aZ )
  {
    // The following code is used during prototyping only. It simply returns
    // a dummy value. No device specific API is used during prototyping.
    $if $prototyper
     
    $endif

    trace "TRPostition: X:"+string(aX)+" Y:"+string(aY)+" Z:"+string(aZ);

    $if !$prototyper
     
    $endif
  }

  $rect <720,200,920,240>
  method void SetWastePosition( arg int32 aX, arg int32 aY, arg int32 aZ )
  {
    // The following code is used during prototyping only. It simply returns
    // a dummy value. No device specific API is used during prototyping.
    $if $prototyper

    $endif

    trace "WastePostition: X:"+string(aX)+" Y:"+string(aY)+" Z:"+string(aZ);

    $if !$prototyper
     
    $endif
  }

  $rect <720,280,920,320>
  method void SetCurrentPosition( arg int32 aX, arg int32 aY, arg int32 aZ )
  {
    // The following code is used during prototyping only. It simply returns
    // a dummy value. No device specific API is used during prototyping.
    $if $prototyper

    $endif

    trace "CurrentPostition: X:"+string(aX)+" Y:"+string(aY)+" Z:"+string(aZ);

    $if !$prototyper
     
    $endif
  }

  // Configuration
  note group Note
  {
    attr Bounds = <700,40,1330,440>;
  }

  // Events
  note group Note1
  {
    attr Bounds = <20,40,650,490>;
  }

  $rect <720,240,920,280>
  method void SetTopPosition( arg int32 aX, arg int32 aY, arg int32 aZ )
  {
    // The following code is used during prototyping only. It simply returns
    // a dummy value. No device specific API is used during prototyping.
    $if $prototyper

    $endif

    trace "TopPostition: X:"+string(aX)+" Y:"+string(aY)+" Z:"+string(aZ);

    $if !$prototyper
     
    $endif
  }

  $rect <240,130,440,170>
  property float Temperature = 0.0;

  $rect <440,130,640,170>
  onset Temperature
  {
    // The property doesn't change -> nothing to do.
    if ( pure Temperature == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Temperature = value;
    trace "Temperature: "+string(Temperature);

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Temperature;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <40,130,240,170>
  $output true
  method void UpdateTemperature( arg float aNewArgument )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewArgument != pure Temperature )
    {
      // Remember the new value in the internal memory of the property.
      pure Temperature = aNewArgument;
      trace "Temperature: "+string(Temperature);

      // Notify all associated property observers.
      notifyobservers ^Temperature;
    }
  }

  // Software
  note group Note2
  {
    attr Bounds = <20,500,530,730>;
  }

  $rect <40,540,240,580>
  method color getColor( arg int32 aCircuitNumber )
  {
    switch ( aCircuitNumber )
    {
      case 0  : return #F38900FF;   //schwarz 
      case 1  : return #32CE00FF;  //weiß
      case 2  : return #0736A3FF;  //gelb
      case 3  : return #0000FFFF;  //blau
      case 4  : return #00FFFFFF; //türkis
      case 5  : return #FF00FFFF;  //lila
      default : return #FF0000FF; //rot=ERROR
    }

      

      

  }

  $rect <240,380,440,420>
  object Core::SystemEvent CurrentTimeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,380,240,420>
  $output true
  method void onCurrentTime( arg string aCurrentTime )
  {
    var Device::CurrentTimeContext context = new Device::CurrentTimeContext;


    context.CurrentTime=aCurrentTime;
    CurrentTimeEvent.Trigger( context, false );
  }

  $rect <240,430,440,470>
  object Core::SystemEvent TimeTillFullEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,430,240,470>
  $output true
  method void onTimeTillFull( arg string aTimeTillFull )
  {
    var Device::TimeTillFullContext context = new Device::TimeTillFullContext;


    context.TimeTillFull=aTimeTillFull;
    TimeTillFullEvent.Trigger( context, false );
  }
}

$rect <60,110,260,150>
autoobject Device::DeviceClass Device;

$rect <600,60,800,100>
$output false
class SampleCollectedContext
{
  $rect <40,40,240,80>
  property point WellIndex = <0,0>;

  $rect <40,80,240,120>
  onset WellIndex
  {
    // The value doesn't change - nothing to do.
    if ( pure WellIndex == value )
      return;

    // Remember the property's new value.
    pure WellIndex = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <40,120,240,160>
  onget WellIndex
  {
    return pure WellIndex;
  }

  $rect <260,40,460,80>
  property int32 CircuitNumber = 0;

  $rect <260,80,460,120>
  onset CircuitNumber
  {
    // The value doesn't change - nothing to do.
    if ( pure CircuitNumber == value )
      return;

    // Remember the property's new value.
    pure CircuitNumber = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <260,120,460,160>
  onget CircuitNumber
  {
    return pure CircuitNumber;
  }

  $rect <480,40,680,80>
  property string Time = "";

  $rect <480,80,680,120>
  onset Time
  {
    // The value doesn't change - nothing to do.
    if ( pure Time == value )
      return;

    // Remember the property's new value.
    pure Time = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <480,120,680,160>
  onget Time
  {
    return pure Time;
  }
}

$rect <600,100,800,140>
$output false
class RemainingTimeContext
{
  $rect <10,10,210,50>
  property int32 RemainingTime = 0;

  $rect <10,50,210,90>
  onset RemainingTime
  {
    // The value doesn't change - nothing to do.
    if ( pure RemainingTime == value )
      return;

    // Remember the property's new value.
    pure RemainingTime = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <10,90,210,130>
  onget RemainingTime
  {
    return pure RemainingTime;
  }

  $rect <220,10,420,50>
  property int32 CircuitNumber = 0;

  $rect <220,50,420,90>
  onset CircuitNumber
  {
    // The value doesn't change - nothing to do.
    if ( pure CircuitNumber == value )
      return;

    // Remember the property's new value.
    pure CircuitNumber = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <220,90,420,130>
  onget CircuitNumber
  {
    return pure CircuitNumber;
  }
}

// System Event Context
note group Note
{
  attr Bounds = <540,10,840,260>;
}

// Device Interface
note group Note1
{
  attr Bounds = <10,20,310,220>;
}

$rect <600,140,800,180>
$output false
class CurrentTimeContext
{
  $rect <20,20,220,60>
  property string CurrentTime = "00.00.0000 00:00:00";

  $rect <20,60,220,100>
  onset CurrentTime
  {
    // The value doesn't change - nothing to do.
    if ( pure CurrentTime == value )
      return;

    // Remember the property's new value.
    pure CurrentTime = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,100,220,140>
  onget CurrentTime
  {
    return pure CurrentTime;
  }
}

$rect <600,180,800,220>
$output false
class TimeTillFullContext
{
  $rect <20,20,220,60>
  property string TimeTillFull = "00.00.0000 00:00:00";

  $rect <20,60,220,100>
  onset TimeTillFull
  {
    // The value doesn't change - nothing to do.
    if ( pure TimeTillFull == value )
      return;

    // Remember the property's new value.
    pure TimeTillFull = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,100,220,140>
  onget TimeTillFull
  {
    return pure TimeTillFull;
  }
}
