$version 6.60

$rect <980,130,1180,170>
inline I2CHeader
{
  #include <unistd.h>				//Needed for I2C port
  #include <fcntl.h>				//Needed for I2C port
  #include <sys/ioctl.h>			//Needed for I2C port
  #include <linux/i2c-dev.h>		//Needed for I2C port
  #include <stdio.h>
  #include <time.h>
}

// This is the root component of the entire GUI application.
$rect <360,20,560,60>
$output false
class Application : Core::Root
{
  $rect <820,0,1020,40>
  inherited property Bounds = <0,0,800,480>;

  // To do:
  // 
  // - The simplest way to compose the appearance of the application is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To store values use the 'Variable', 'Array' and 'Property' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  note legend Note1
  {
    attr Bounds = <10,500,790,700>;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,800,480>;
    preset SnapLast = <800,0>;
    preset SlideHorz = true;
    preset SlideVert = false;
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <0,0,800,480>;
    preset SlideHandler = SlideTouchHandler;
    preset Formation = Core::Formation.LeftToRight;
  }

  $rect <20,20,160,60>
  object Application::MainMenu MainMenu
  {
    preset Bounds = <49,720,849,1200>;
    preset Enabled = true;
    preset Embedded = true;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Application::Well WellObj
  {
    preset Bounds = <889,800,1689,1280>;
    preset Enabled = true;
    preset Embedded = true;
    preset Visible = true;
  }
}

$rect <130,120,330,160>
$output false
class MainMenu : Core::Group
{
  $rect <10,600,210,640>
  inherited property Bounds = <0,0,800,480>;

  $rect <10,560,210,600>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,520,210,560>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Application::ControllMenu ControllMenue
  {
    preset Bounds = <0,0,800,480>;
    preset Config = Config;
  }

  $rect <20,20,160,60>
  object Application::Config Config
  {
    preset Bounds = <960,1210,1760,1690>;
    preset Visible = true;
    preset ControllMenue = ControllMenue;
  }
}

$rect <580,120,780,160>
$output false
class Well : Core::Group
{
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,480>;
    preset Color = Application::BackgroundColor;
  }

  $rect <0,560,200,600>
  inherited property Bounds = <0,0,800,480>;

  $rect <0,650,200,690>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,610,200,650>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Application::WellPart A1
  {
    preset Bounds = <70,50,140,120>;
    preset TimeProperty = "19.01.2018 14:38:12";
    preset CircuitNumber = 0;
  }

  $rect <20,20,160,60>
  object Application::WellPart B1
  {
    preset Bounds = <70,120,140,190>;
  }

  $rect <20,20,160,60>
  object Application::WellPart C1
  {
    preset Bounds = <70,190,140,260>;
  }

  $rect <20,20,160,60>
  object Application::WellPart D1
  {
    preset Bounds = <70,260,140,330>;
  }

  $rect <20,20,160,60>
  object Application::WellPart E1
  {
    preset Bounds = <70,330,140,400>;
  }

  $rect <20,20,160,60>
  object Application::WellPart F1
  {
    preset Bounds = <70,400,140,470>;
  }

  $rect <20,20,160,60>
  object Application::WellPart A2
  {
    preset Bounds = <140,50,210,120>;
    preset TimeProperty = "19.01.2018 14:38:12";
    preset CircuitNumber = 1;
  }

  $rect <20,20,160,60>
  object Application::WellPart B2
  {
    preset Bounds = <140,120,210,190>;
  }

  $rect <20,20,160,60>
  object Application::WellPart C2
  {
    preset Bounds = <140,190,210,260>;
  }

  $rect <20,20,160,60>
  object Application::WellPart D2
  {
    preset Bounds = <140,260,210,330>;
  }

  $rect <20,20,160,60>
  object Application::WellPart E2
  {
    preset Bounds = <140,330,210,400>;
  }

  $rect <20,20,160,60>
  object Application::WellPart F2
  {
    preset Bounds = <140,400,210,470>;
  }

  $rect <20,20,160,60>
  object Application::WellPart A3
  {
    preset Bounds = <210,50,280,120>;
    preset TimeProperty = "19.01.2018 14:43";
    preset CircuitNumber = 2;
  }

  $rect <20,20,160,60>
  object Application::WellPart B3
  {
    preset Bounds = <210,120,280,190>;
  }

  $rect <20,20,160,60>
  object Application::WellPart C3
  {
    preset Bounds = <210,190,280,260>;
  }

  $rect <20,20,160,60>
  object Application::WellPart D3
  {
    preset Bounds = <210,260,280,330>;
  }

  $rect <20,20,160,60>
  object Application::WellPart E3
  {
    preset Bounds = <210,330,280,400>;
  }

  $rect <20,20,160,60>
  object Application::WellPart F3
  {
    preset Bounds = <210,400,280,470>;
  }

  $rect <20,20,160,60>
  object Application::WellPart A4
  {
    preset Bounds = <280,50,350,120>;
    preset TimeProperty = "19.01.2018 14:38:12";
    preset CircuitNumber = 3;
  }

  $rect <20,20,160,60>
  object Application::WellPart B4
  {
    preset Bounds = <280,120,350,190>;
  }

  $rect <20,20,160,60>
  object Application::WellPart C4
  {
    preset Bounds = <280,190,350,260>;
  }

  $rect <20,20,160,60>
  object Application::WellPart D4
  {
    preset Bounds = <280,260,350,330>;
  }

  $rect <20,20,160,60>
  object Application::WellPart E4
  {
    preset Bounds = <280,330,350,400>;
  }

  $rect <20,20,160,60>
  object Application::WellPart F4
  {
    preset Bounds = <280,400,350,470>;
  }

  $rect <20,20,160,60>
  object Application::WellPart A5
  {
    preset Bounds = <350,50,420,120>;
    preset TimeProperty = "19.01.2018 14:38:12";
    preset CircuitNumber = 4;
  }

  $rect <20,20,160,60>
  object Application::WellPart B5
  {
    preset Bounds = <350,120,420,190>;
  }

  $rect <20,20,160,60>
  object Application::WellPart C5
  {
    preset Bounds = <350,190,420,260>;
  }

  $rect <20,20,160,60>
  object Application::WellPart D5
  {
    preset Bounds = <350,260,420,330>;
  }

  $rect <20,20,160,60>
  object Application::WellPart E5
  {
    preset Bounds = <350,330,420,400>;
  }

  $rect <20,20,160,60>
  object Application::WellPart F5
  {
    preset Bounds = <350,400,420,470>;
  }

  $rect <20,20,160,60>
  object Application::WellPart A6
  {
    preset Bounds = <420,50,490,120>;
    preset TimeProperty = "19.01.2018 14:38:12";
    preset CircuitNumber = 5;
  }

  $rect <20,20,160,60>
  object Application::WellPart B6
  {
    preset Bounds = <420,120,490,190>;
  }

  $rect <20,20,160,60>
  object Application::WellPart C6
  {
    preset Bounds = <420,190,490,260>;
  }

  $rect <20,20,160,60>
  object Application::WellPart D6
  {
    preset Bounds = <420,260,490,330>;
  }

  $rect <20,20,160,60>
  object Application::WellPart E6
  {
    preset Bounds = <420,330,490,400>;
  }

  $rect <20,20,160,60>
  object Application::WellPart F6
  {
    preset Bounds = <420,400,490,470>;
  }

  $rect <20,20,160,60>
  object Application::WellPart A7
  {
    preset Bounds = <490,50,560,120>;
    preset TimeProperty = "19.01.2018 14:38:12";
    preset CircuitNumber = 6;
  }

  $rect <20,20,160,60>
  object Application::WellPart B7
  {
    preset Bounds = <490,120,560,190>;
  }

  $rect <20,20,160,60>
  object Application::WellPart C7
  {
    preset Bounds = <490,190,560,260>;
  }

  $rect <20,20,160,60>
  object Application::WellPart D7
  {
    preset Bounds = <490,260,560,330>;
  }

  $rect <20,20,160,60>
  object Application::WellPart E7
  {
    preset Bounds = <490,330,560,400>;
  }

  $rect <20,20,160,60>
  object Application::WellPart F7
  {
    preset Bounds = <490,400,560,470>;
  }

  $rect <20,20,160,60>
  object Application::WellPart A8
  {
    preset Bounds = <560,50,630,120>;
  }

  $rect <20,20,160,60>
  object Application::WellPart B8
  {
    preset Bounds = <560,120,630,190>;
  }

  $rect <20,20,160,60>
  object Application::WellPart C8
  {
    preset Bounds = <560,190,630,260>;
  }

  $rect <20,20,160,60>
  object Application::WellPart D8
  {
    preset Bounds = <560,260,630,330>;
  }

  $rect <20,20,160,60>
  object Application::WellPart E8
  {
    preset Bounds = <560,330,630,400>;
  }

  $rect <20,20,160,60>
  object Application::WellPart F8
  {
    preset Bounds = <560,400,630,470>;
  }

  $rect <20,20,160,60>
  object Application::Clock Time
  {
    preset Bounds = <670,400,790,470>;
  }

  // Writes the given Time in the chosen WellPart
  $rect <1210,300,1410,340>
  method void timeToWellPart( arg int32 aCircuitNumber, arg int32 aColumn, arg int32 aRow, arg string aTime )
  {
    WellPartArray[aColumn,aRow].TimeProperty=aTime;
    WellPartArray[aColumn,aRow].CircuitNumber=aCircuitNumber;




  }

  // Stores all Well Parts
  $rect <820,80,1020,120>
  array Application::WellPart WellPartArray[ 8,6 ] =
  (
    Default[0, 0] = A1;
    Default[0, 1] = B1;
    Default[0, 2] = C1;
    Default[0, 3] = D1;
    Default[0, 4] = E1;
    Default[0, 5] = F1;
    Default[1, 0] = A2;
    Default[1, 1] = B2;
    Default[1, 2] = C2;
    Default[1, 3] = D2;
    Default[1, 4] = E2;
    Default[1, 5] = F2;
    Default[2, 0] = A3;
    Default[2, 1] = B3;
    Default[2, 2] = C3;
    Default[2, 3] = D3;
    Default[2, 4] = E3;
    Default[2, 5] = F3;
    Default[3, 0] = A4;
    Default[3, 1] = B4;
    Default[3, 2] = C4;
    Default[3, 3] = D4;
    Default[3, 4] = E4;
    Default[3, 5] = F4;
    Default[4, 0] = A5;
    Default[4, 1] = B5;
    Default[4, 2] = C5;
    Default[4, 3] = D5;
    Default[4, 4] = E5;
    Default[4, 5] = F5;
    Default[5, 0] = A6;
    Default[5, 1] = B6;
    Default[5, 2] = C6;
    Default[5, 3] = D6;
    Default[5, 4] = E6;
    Default[5, 5] = F6;
    Default[6, 0] = A7;
    Default[6, 1] = B7;
    Default[6, 2] = C7;
    Default[6, 3] = D7;
    Default[6, 4] = E7;
    Default[6, 5] = F7;
    Default[7, 0] = A8;
    Default[7, 1] = B8;
    Default[7, 2] = C8;
    Default[7, 3] = D8;
    Default[7, 4] = E8;
    Default[7, 5] = F8;
  );

  $rect <20,20,160,60>
  object Views::WarpImage Logo
  {
    preset Point4 = <700,110>;
    preset Point3 = <800,110>;
    preset Point2 = <800,10>;
    preset Point1 = <700,10>;
    preset Bitmap = Application::Logo;
  }

  $rect <20,20,160,60>
  object Application::WellLabel WellLabel
  {
    preset Bounds = <70,10,140,50>;
    preset TextString = "1";
  }

  $rect <20,20,160,60>
  object Application::WellLabel WellLabel1
  {
    preset Bounds = <140,10,210,50>;
    preset TextString = "2";
  }

  $rect <20,20,160,60>
  object Application::WellLabel WellLabel2
  {
    preset Bounds = <210,10,280,50>;
    preset TextString = "3";
  }

  $rect <20,20,160,60>
  object Application::WellLabel WellLabel3
  {
    preset Bounds = <280,10,350,50>;
    preset TextString = "4";
  }

  $rect <20,20,160,60>
  object Application::WellLabel WellLabel4
  {
    preset Bounds = <350,10,420,50>;
    preset TextString = "5";
  }

  $rect <20,20,160,60>
  object Application::WellLabel WellLabel5
  {
    preset Bounds = <420,10,490,50>;
    preset TextString = "6";
  }

  $rect <20,20,160,60>
  object Application::WellLabel WellLabel6
  {
    preset Bounds = <490,10,560,50>;
    preset TextString = "7";
  }

  $rect <20,20,160,60>
  object Application::WellLabel WellLabel7
  {
    preset Bounds = <560,10,630,50>;
    preset TextString = "8";
  }

  $rect <20,20,160,60>
  object Application::WellLabel WellLabelA
  {
    preset Bounds = <0,60,70,100>;
    preset TextString = "A";
  }

  $rect <20,20,160,60>
  object Application::WellLabel WellLabelB
  {
    preset Bounds = <0,130,70,170>;
    preset TextString = "B";
  }

  $rect <20,20,160,60>
  object Application::WellLabel WellLabelC
  {
    preset Bounds = <0,200,70,240>;
    preset TextString = "C";
  }

  $rect <20,20,160,60>
  object Application::WellLabel WellLabelD
  {
    preset Bounds = <0,270,70,310>;
    preset TextString = "D";
  }

  $rect <20,20,160,60>
  object Application::WellLabel WellLabelE
  {
    preset Bounds = <0,340,70,380>;
    preset TextString = "E";
  }

  $rect <20,20,160,60>
  object Application::WellLabel WellLabelF
  {
    preset Bounds = <0,410,70,450>;
    preset TextString = "F";
  }

  $rect <820,190,1020,230>
  object Core::PropertyObserver NewWellObserver
  {
    preset OnEvent = onNewWell;
    preset Outlet = ^Device::Device.NewWell;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <1020,190,1220,230>
  slot onNewWell
  {
    var int32 r;
    var int32 c;

    for(r=0; r<6;r=r+1){
      for(c=0;c<8;c=c+1){
        WellPartArray[c,r].Text.String="";
      }
    }

  }

  $rect <1030,80,1230,120>
  array Application::WellLabel WellLabelArray[ 6 ] =
  (
    Default[0] = WellLabelA;
    Default[1] = WellLabelB;
    Default[2] = WellLabelC;
    Default[3] = WellLabelD;
    Default[4] = WellLabelE;
    Default[5] = WellLabelF;
  );

  $rect <820,300,1020,340>
  object Core::SystemEventHandler SampleCollected
  {
    preset OnEvent = onSampleCollected;
    preset Event = Device::Device.SampleCollectedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1020,300,1220,340>
  slot onSampleCollected
  {
    var Device::SampleCollectedContext context = (Device::SampleCollectedContext)SampleCollected.Context;
     
    timeToWellPart(context.CircuitNumber,context.WellIndex.x,context.WellIndex.y,context.Time);
     


  }

  $reorder Rectangle 76
}

$rect <610,160,810,200>
$output false
class WellPart : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,70,70>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::WarpImage WarpImage
  {
    preset Point4 = <0,70>;
    preset Point3 = <70,70>;
    preset Point2 = <70,0>;
    preset Point1 = <0,0>;
    preset Bitmap = Application::Oval;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,20,70,50>;
    preset RowDistance = 14;
    preset AutoSize = false;
    preset WrapWidth = 0;
    preset WrapText = true;
    preset String = "";
    preset Font = Application::FontArial17;
    preset Color = #FFFFFFFF;
  }

  $rect <90,10,290,50>
  property string TimeProperty = "";

  $rect <90,50,290,90>
  onset TimeProperty
  {
    // The value doesn't change - nothing to do.
    if ( pure TimeProperty == value )
      return;


    // Remember the property's new value.
    pure TimeProperty = value;

    Text.String = TimeProperty;


    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <90,90,290,130>
  onget TimeProperty
  {
    return pure TimeProperty;
  }

  $rect <300,10,500,50>
  property point Coordinate = <0,0>;

  $rect <300,50,500,90>
  onset Coordinate
  {
    // The value doesn't change - nothing to do.
    if ( pure Coordinate == value )
      return;

    // Remember the property's new value.
    pure Coordinate = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <300,90,500,130>
  onget Coordinate
  {
    return pure Coordinate;
  }

  $rect <530,10,730,50>
  property int32 CircuitNumber = 0;

  $rect <530,50,730,90>
  onset CircuitNumber
  {
    Text.Color=Device::Device.getColor( value );
                      

    // The value doesn't change - nothing to do.
    if ( pure CircuitNumber == value )
      return;

    // Remember the property's new value.
    pure CircuitNumber = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <530,90,730,130>
  onget CircuitNumber
  {
    return pure CircuitNumber;
  }
}

$rect <570,650,770,690>
$output false
resource Resources::Bitmap Oval
{
  attr bitmapfile FileName = .\Resources\oval.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <560,440,760,480>
$output false
class Clock : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,120,60>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <250,60,450,100>
  slot Slot
  {
    var Core::Time currentT= Time.CurrentTime;
    TimeProperty=string(currentT.Day)+"."+string(currentT.Month)+"."+string(currentT.Year)[2]+string(currentT.Year)[3]+" "+string(currentT.Hour)+":"+string(currentT.Minute)+":"+string(currentT.Second);
  }

  $rect <250,0,450,40>
  object Core::Timer Timer
  {
    preset OnTrigger = Slot;
    preset Period = 500;
    preset Begin = 0;
    preset Enabled = true;
  }

  $rect <20,20,160,60>
  object Views::Text TimeText
  {
    preset Bounds = <0,0,120,60>;
    preset AutoSize = false;
    preset WrapText = true;
    preset String = "00.00.0000 00:00:00";
    preset Font = Flat::FontM;
  }

  $rect <250,100,450,140>
  object Core::Time Time;

  $rect <500,20,700,60>
  property string TimeProperty = "00.00.0000 00:00:00";

  $rect <500,60,700,100>
  onset TimeProperty
  {
    // The value doesn't change - nothing to do.
    if ( pure TimeProperty == value )
      return;
    TimeText.String=TimeProperty;

    // Remember the property's new value.
    pure TimeProperty = value;


    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <500,100,700,140>
  onget TimeProperty
  {
    return pure TimeProperty;
  }
}

$rect <150,290,350,330>
$output false
class SampleController : Core::Group
{
  $rect <20,550,220,590>
  inherited property Bounds = <0,0,420,70>;

  $rect <20,630,220,670>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <20,590,220,630>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <310,130,510,170>
  property char NameProperty = 0;

  $rect <310,170,510,210>
  onset NameProperty
  {
    // The value doesn't change - nothing to do.
    if ( pure NameProperty == value )
      return;

    // Remember the property's new value.
    pure NameProperty = value;

    NameText.String=NameProperty;
    NameText.Color=Device::Device.getColor( NameText.String.parse_int32( -1 )-1 );

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <310,210,510,250>
  onget NameProperty
  {
    return pure NameProperty;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,1,418,69>;
    preset Width = 3;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text NameText
  {
    preset Bounds = <0,1,30,31>;
    preset String = "1";
    preset Font = Flat::FontM;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Application::AActionButton BtnStart
  {
    preset Bounds = <120,6,200,31>;
    preset OnAction = onStart;
    preset Caption = "Start";
  }

  $rect <20,20,160,60>
  object Application::AActionButton BtnStop
  {
    preset Bounds = <120,40,200,65>;
    preset Enabled = false;
    preset OnAction = onStop;
    preset Caption = "Stop";
  }

  $rect <20,20,160,60>
  object Application::AIndicator Indicator
  {
    preset Bounds = <380,20,410,50>;
  }

  $rect <30,180,230,220>
  slot onStart
  {
    if(TextEditor.String.parse_int32(0)>0){ //User has to enter a Integer > 0
      HorzBar.MaxValue=TextEditor.String.parse_int32( 0 );
      HorzBar.CurrentValue=TextEditor.String.parse_int32( 0 );
      EnabledProperty=true;
      Device::Device.StartSampling( TextEditor.String.parse_int32(1), string(NameProperty).parse_int32(0) -1);
    }




  }

  $rect <310,270,510,310>
  property bool EnabledProperty = false;

  $rect <310,310,510,350>
  onset EnabledProperty
  {
    // The value doesn't change - nothing to do.
    if ( pure EnabledProperty == value )
      return;

    // Remember the property's new value.
    pure EnabledProperty = value;
    if(EnabledProperty){
      BtnStart.Enabled=false;
      BtnStop.Enabled=true;
    }else{
      BtnStart.Enabled=true;
      BtnStop.Enabled=false;
    }


    Indicator.Active=EnabledProperty;
  }

  $rect <310,350,510,390>
  onget EnabledProperty
  {
    return pure EnabledProperty;
  }

  $rect <30,140,230,180>
  slot onStop
  {
    EnabledProperty=false;
    Device::Device.StopSampling( string(NameProperty).parse_int32(0) -1 );

  }

  $rect <30,260,230,300>
  method void WellFull()
  {
    EnabledProperty=false;
    BtnStart.Enabled=false;
  }

  $rect <20,20,160,60>
  object Application::TextEditor TextEditor
  {
    preset Bounds = <30,20,70,60>;
    preset WrapText = false;
    preset String = "10";
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <110,45>;
    preset Point1 = <30,45>;
    preset Width = 2;
    preset Color = #000000FF;
  }

  $rect <590,110,790,150>
  object Core::PropertyObserver NewWellObserver
  {
    preset OnEvent = onNewWell;
    preset Outlet = ^Device::Device.NewWell;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <590,150,790,190>
  slot onNewWell
  {
    if(!EnabledProperty){ //So that you cant activate the Start Button while its already running
      BtnStart.Enabled=true;
    }




  }

  // Properties
  note group Note
  {
    attr Bounds = <280,90,540,540>;
  }

  // Timing
  note group Note1
  {
    attr Bounds = <10,90,260,360>;
  }

  $rect <310,400,510,440>
  property int32 RemainingTime = 0;

  $rect <310,440,510,480>
  onset RemainingTime
  {
    // The value doesn't change - nothing to do.
    if ( pure RemainingTime == value )
      return;

    // Remember the property's new value.
    pure RemainingTime = value;

    HorzBar.CurrentValue=RemainingTime;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <310,480,510,520>
  onget RemainingTime
  {
    return pure RemainingTime;
  }

  $rect <20,20,160,60>
  object Application::AHorzBar HorzBar
  {
    preset Bounds = <210,10,370,60>;
  }

  $rect <20,20,160,60>
  object Flat::Label Label
  {
    preset Bounds = <70,20,110,50>;
    preset String = "min";
    preset TextColor = #000000FF;
  }

  $reorder OnSetOpacity 8
  $reorder OnGetEmbedded 8
  $reorder OnSetEmbedded 8
  $reorder OnGetAlphaBlended 8
  $reorder OnSetAlphaBlended 8
  $reorder OnGetVisible 8
  $reorder OnSetVisible 8
  $reorder ObtainFocus 8
  $reorder HasViewState 8
  $reorder LocalPosition 8
  $reorder GlobalPosition 8
  $reorder DispatchEvent 8
  $reorder BroadcastEventAtPosition 8
  $reorder BroadcastEvent 8
  $reorder UpdateLayout 8
  $reorder UpdateViewState 8
  $reorder InvalidateViewState 8
  $reorder InvalidateArea 8
  $reorder Init 8
  $reorder GetIndexOfView 8
  $reorder GetViewAtIndex 8
  $reorder CountViews 8
  $reorder FindViewInDirection 8
  $reorder FindViewWithinArea 8
  $reorder FindViewAtPosition 8
  $reorder FindPrevView 8
  $reorder FindNextView 8
  $reorder FindSiblingView 8
  $reorder GetContentArea 8
  $reorder RestackBehind 8
  $reorder RestackBack 8
  $reorder RestackTop 8
  $reorder Restack 8
  $reorder Remove 8
  $reorder AddBehind 8
  $reorder Add 8
  $reorder Focus 8
  $reorder Buffered 8
  $reorder Opacity 9
  $reorder Embedded 9
  $reorder AlphaBlended 9
  $reorder Visible 9
  $reorder NameProperty 9
  $reorder OnSetNameProperty 9
  $reorder OnGetNameProperty 9
  $reorder Border 9
  $reorder NameText 9
  $reorder BtnStart 9
  $reorder BtnStop 9
  $reorder Indicator 9
  $reorder onStart 9
  $reorder Enabled 5
  $reorder OnSetEnabled 1
}

$rect <570,610,770,650>
$output false
resource Resources::Bitmap Logo
{
  attr bitmapfile FileName = .\Resources\Logo.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <570,570,770,610>
$output false
resource Resources::Font FontArial17
{
  attr fontname FontName = Arial;
  attr fontheight Height = 16;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
}

// This component implements an editor.
$rect <560,360,760,400>
$output false
class TextEditor : Templates::TextEditor
{
  $rect <670,620,870,660>
  inherited property Bounds = <0,0,160,130>;

  $rect <680,280,880,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited version of the method
    super( aState );

    // Activate the caret blinking if the editor component has the input focus
    if ( aState.contains( Core::ViewState[ Focused ]))
      blinkEffect.Enabled = true;

    // ... otherwise hide the caret
    else
    {
      blinkEffect.Enabled = false;
      Caret.Visible       = false;
    }
  }

  // To do:
  // 
  // - Adjust the visible size of the text editor (the thick blue border). This will \
  // be the editor's default size.
  // - Resize and arrange the member 'Text' so it covers the area where you intend \
  // to display the text. This is usually the entire area.
  // - Adjust the position and the size of the 'SimpleTouchHandler' and 'SlideTouchHandler', \
  // so they cover the 'Text' view.
  // - If your design it expects, add and configure more views in the component, \
  // e.g. views to display background, borders, etc.
  // - The editor implements several handler to process keyboard inputs. See the \
  // annotation 'Keyboard events'. Feel free to add more handler for other key events \
  // or remove the handler you don't need in your version.
  // - The editor displays a magnifying glass when the user touches and holds the \
  // finger for a while (see the method 'onHoldTouch'). If you don't want it, remove \
  // the contents within the annotation 'Magnifying glass' and the slot method 'onHoldTouch'.
  // - The editor reacts to touch interactions. See the annotation 'Touch screen \
  // events'. If your device is not touch driven, you can remove the both handlers \
  // 'SimpleTouchHandler', 'SlideTouchHandler' and the methods from the annotation \
  // 'Touch screen events'.
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the editor's current state (e.g. focused editor \
  // may appear with other colors, etc.)
  // - The editor is implemented with various properties allowing the configuration \
  // of the text (e.g. 'Font', 'Color', ...). If your version of the editor doesn't \
  // need such configuration, remove the properties and the associated OnSet methods.
  // - If you need other properties to configure the editor, add from the Gallery \
  // folder 'Chora' new properties. One property for every new setting (e.g. 'BorderWidth', \
  // etc.)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'BorderWidth' should update the eventually used 'Border' \
  // view, etc.).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note6
  {
    attr Bounds = <10,690,990,1150>;
  }

  // Magnifying glass
  note group Note5
  {
    attr Bounds = <440,500,660,670>;
  }

  // Caret
  note group Note4
  {
    attr Bounds = <10,500,430,670>;
  }

  // State management
  note group Note3
  {
    attr Bounds = <670,240,890,330>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <440,240,660,450>;
  }

  // Keyboard events
  note group Note1
  {
    attr Bounds = <10,240,430,490>;
  }

  // This internal variable refers to a temporary Views::Image object used to show \
  // the background for the augmented text content around the caret. This view appears \
  // during the user is moving this caret by touching the caret with the finger.
  $rect <450,620,650,660>
  var Views::Rectangle magnifyingBack = null;

  // This internal variable refers to a temporary Views::WarpGroup object used to \
  // show the augmented text content around the caret. This view appears during the \
  // user is moving this caret by touching the caret with the finger.
  $rect <450,580,650,620>
  var Views::WarpGroup magnifyingView = null;

  // This flag is set if it is evtl. necessary to scroll the editor content in order \
  // to ensure that the caret is still visible.
  $rect <220,620,420,660>
  var bool autoScroll;

  // This internal variable stores the current caret index. This is the position \
  // within Text.String property where the user can input text or delete signs.
  $rect <20,620,220,660>
  var int32 caretIndex = 0;

  // This slot method is called after the caret has been adjusted. Its job is to \
  // adjust too the position of the magnifying glass view where the augmented text \
  // content around the caret is shown.
  $rect <450,540,650,580>
  slot updateMagnifyingView
  {
    // There is actually no magnifying glass displayed. Nothing to do.
    if ( magnifyingView == null )
      return;

    var rect  srcArea = magnifyingView.SourceArea;
    var rect  extent  = magnifyingView.GetExtent();
    var rect  bounds  = Bounds;
    var point caret   = Caret.Point1;

    // Calculate the start position of the area to show in the magnifying
    // view. Preferably the caret should appear in the center of this area.
    var int32 srcX = caret.x - ( srcArea.w / 2 );

    // However, the part of magnifying glass displaying the caret should 
    // remain arranged horizontally within the editor area.
    if ( srcX < 0 )
      srcX = 0;

    if (( srcX + srcArea.w ) > bounds.w )
      srcX = bounds.w - srcArea.w;

    // The resulting start position of the area to augment
    magnifyingView.SourceArea.origin = point( srcX, caret.y );

    // Now calculate the position for the magnifyingView. Preferably the
    // the view should be arranged so it shows the augmented caret 
    // exactly above the origin caret
    var int32 dstX = ( bounds.x1 + caret.x ) - ( caret.x - srcX ) * 2;

    // From the new magnifyingView position and its current position calculate
    // an offset.
    var point ofs = point( dstX - extent.x1, bounds.y1 + caret.y - extent.y2 );

    // Move the magnifyingView and its background by the just calculated offset
    magnifyingView.MoveView( ofs, false );
    magnifyingBack.MoveView( ofs, false );
  }

  // This slot method is called after a short delay when the user has moved the caret \
  // or modified the text. Its job is to ensure that the caret is still visible. \
  // If necessary, the editor content is scrolled.
  $rect <220,540,420,580>
  slot updateScrollOffset
  {
    // Get the visible area of the text view
    var rect  bounds = Text.Bounds;
    var int32 ofsX   = 0;
    var int32 ofsY   = 0;

    // Calculate an offset to scroll the text content if the caret lies
    // outside the visible area
    if ( Caret.Point1.x < bounds.x1 ) ofsX = bounds.x1 - Caret.Point1.x;
    if ( Caret.Point1.x > bounds.x2 ) ofsX = bounds.x2 - Caret.Point1.x;
    if ( Caret.Point1.y < bounds.y1 ) ofsY = bounds.y1 - Caret.Point1.y;
    if ( Caret.Point2.y > bounds.y2 ) ofsY = bounds.y2 - Caret.Point2.y;

    // Should the cont be scrolled?
    if (( ofsX != 0 ) || ( ofsY != 0 ))
      Text.ScrollOffset = Text.ScrollOffset + point( ofsX, ofsY );

    // The following code takes care of the automatic adjustment of the
    // text scroll position if after modifying the text, its area is small
    // enough to be completely visible.
    ofsX = Text.ScrollOffset.x;
    ofsY = Text.ScrollOffset.y;

    // Get the current text area of the 
    var point size = Text.GetContentArea().size;

    // Does the area fit completely within the text editor?
    if ( size.x <= Text.Bounds.w ) ofsX = 0;
    if ( size.y <= Text.Bounds.h ) ofsY = 0;

    // If possible arrange the text so it fits within the text editor.
    Text.ScrollOffset = point( ofsX, ofsY );
  }

  // This slot method is attached to the Text view. Each time the Text view has rearranged \
  // the text, this method is called. Its job is to adjust the caret to the evtl. \
  // new position.
  $rect <20,540,220,580>
  slot updateCaret
  {
    // Without the font we don't know the height of the caret
    if ( Font == null )
      return;

    // Get the pixel position of the sign right to the caret
    var point rowCol = Text.StringIndex2RowCol( caretIndex );
    var point pos    = Text.RowCol2Position( rowCol );

    // Arrange the caret at the just determined position. The height of 
    // the caret corresponds to the height of a text row drawn with the
    // font
    Caret.Point1 = pos - point( 0, Font.Ascent  );
    Caret.Point2 = pos + point( 0, Font.Descent );

    // Restart the blink effect -> this ensures that the user can see the
    // caret while it is moved or the text is modified
    if ( blinkEffect.Enabled )
    {
      blinkEffect.Enabled = false;
      blinkEffect.Enabled = true;
    }

    // Should adjust the scroll position so that the caret remains in the visible
    // area? Finally clear the 'autoScroll' flag again.
    if ( autoScroll )
    {
      postsignal updateScrollOffset;
      autoScroll = false;
    }

    // If there is a magnifying glass view visible -> arrange it also to the
    // current caret position.
    if ( magnifyingView != null )
      postsignal updateMagnifyingView;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to hide the magnifying glass view again.
  $rect <450,400,650,440>
  slot onReleaseTouch
  {
    // Hide the views used temporarily to show the augmented editor content
    if ( magnifyingView != null )
    {
      Owner.Remove( magnifyingView );
      Owner.Remove( magnifyingBack );
      magnifyingView = null;
      magnifyingBack = null;

      // Free the temporary used off-screen memory
      Buffered = false;
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to move the caret accordingly to the user's finger movement.
  $rect <450,360,650,400>
  slot onDragTouch
  {
    // Does the user currently drag the caret?
    if ( magnifyingView != null )
    {
      // From the touched screen position estimate the corresponding position
      // within the text string.
      var point rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
      var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

      // Does the caret position change? Force the editor to update the
      // position of the blinking caret
      if ( newCaretIndex != caretIndex )
      {
        caretIndex = newCaretIndex;
        postsignal updateCaret;

        // Ensure the caret is still visible later in the updateText slot method
        autoScroll = true;
      }
    }

    // No, then redirect the touch interaction to the slide touch handler when the
    // user moved the finger a little bit. In this manner the user can scroll the text.
    else
    {
      var point ofs   = SimpleTouchHandler.CurrentPos - SimpleTouchHandler.HittingPos;
      var int32 limit = GetRoot().CursorDragLimit;

      // Start the slide mode if the user has dragged the finger a little bit
      if (( ofs.x < -limit ) || ( ofs.x > limit ) ||
          ( ofs.y < -limit ) || ( ofs.y > limit ))
        GetRoot().DeflectCursor( SlideTouchHandler, <0,0>);
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to activate the caret movement mode if the user has pressed the finger on the \
  // screen for a while. The method also shows a small magnifying glass where the \
  // text around the caret is shown. This should help the user to navigate the caret \
  // with the finger.
  $rect <450,320,650,360>
  slot onHoldTouch
  {
    // When the user presses the finger within the text editor area,
    // the editor enters the caret dragging mode. In this mode the
    // user can move the caret with the finger. For convenience the
    // area below the finger is displayed in a kind of magnifying glass.
    // Does enter the mode?
    if (( SimpleTouchHandler.HoldPeriod >= 300 ) && ( magnifyingView == null ))
    {
      // Calculate the size of the area to augment
      var int32 height = Caret.Point2.y - Caret.Point1.y;
      var int32 width  = height * 3;

      // Limit to the available size of the editor component
      if ( height > Bounds.h ) height = Bounds.h;
      if ( width  > Bounds.w ) width  = Bounds.w;

      // The editor component should store its content in an off-screen bitmap
      // in order to be able to to show it augmented in an overlay 'magnifyingView'
      Buffered = true;

      // Create a temporary view to show the augmented content and to show the
      // 'magnifying glass' background
      magnifyingView = new Views::WarpGroup;
      magnifyingBack = new Views::Rectangle;

      // Prepare a magnifyingView to show an augmented content of the edited text
      // row. The content is augmented by the factor x 2
      magnifyingView.Group       = this;
      magnifyingView.Quality     = true;
      magnifyingView.Opacity     = 200;
      magnifyingView.SourceArea  = rect( 0, 0, width, height );
      magnifyingView.Point2.x    = width  * 2;
      magnifyingView.Point3.x    = width  * 2;
      magnifyingView.Point3.y    = height * 2;
      magnifyingView.Point4.y    = height * 2;

      // Also prepare the magnifying glass background view. It is a semitransparent
      // rectangle.
      magnifyingBack.Bounds.size   = point( width * 2, height * 2 ) + <20,20>;
      magnifyingBack.Bounds.origin = <-10,-10>;
      magnifyingBack.Color         = #EEEEEECC;

      // Make the just created views visible on the screen
      Owner.Add( magnifyingBack, 0 );
      Owner.Add( magnifyingView, 0 );

      // Arrange the 'magnifying glass' views at the correct position
      postsignal updateMagnifyingView;
    }

    // Even if the user is not moving the cursor (finger) continue the scrolling when
    // the user holds the finger near an edge of the text editor.
    if ( magnifyingView != null )
      signal onDragTouch;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to obtain the focused state for the editor so the user can interact with the \
  // editor content and to place the caret at the touched position.
  $rect <450,280,650,320>
  slot onPressTouch
  {
    // With the first touch focus the text editor
    if ( !HasViewState( Core::ViewState[ Focused ]))
      ObtainFocus();

    // Estimate the position within the text string corresponding to the
    // position touched on the screen.
    var point rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the text editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // move the caret up/down/left or right in the editor text.
  $rect <220,440,420,480>
  slot onCursorKey
  {
    // No font specified to show the text -> no navigation
    // possible
    if ( Font == null )
      return;

    // Knowing the position of the caret within the string, get the
    // corresponding row/column position in the displayed text.
    var point rc = Text.StringIndex2RowCol( caretIndex );

    // Has the user moved the caret to the left? Get the new resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Left )
    {
      // Navigate to the previous column
      rc.x = rc.x - 1;

      // Skip to the end of the preceding row?
      if ( rc.x < 0 )
      {
        rc.y = rc.y - 1;
        rc.x = Text.GetRowString( rc.y ).length;
      }
    }

    // Has the user moved the caret to the right? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Right )
    {
      // Navigate to the next column
      rc.x = rc.x + 1;

      // Skip to the begin of the next row?
      if ( rc.x == Text.GetRowString( rc.y ).length )
      {
        rc.y = rc.y + 1;
        rc.x = 0;
      }
    }

    // Has the user moved the caret one row up? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Up )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just above
      rc = Text.Position2RowCol( pos - point( 0, rowHeight ));
    }

    // Has the user moved the caret one row down? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Down )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just below
      rc = Text.Position2RowCol( pos + point( 0, rowHeight ));
    }

    // From the just determined new row/column position get the corresponding
    // position within the text string
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign preceding the current caret position and to move the caret accordingly.
  $rect <220,400,420,440>
  slot onBackspaceKey
  {
    // No signs preceding the caret -> Nothing to delete
    if ( caretIndex == 0 )
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex - 1 ];
    var int32 count = 1;

    // Is this a space sign? Usually space signs are eliminated by the
    // text view unless we use the non-breakable space sign \xA0. However,
    // to perform the text wrap, a silent break sign '^' is placed behind
    // the space sign. Consider the both signs '\xA0^' as a unit
    if (( caretIndex > 1 ) && ( ch == '^' ) && 
        ( Text.String[ caretIndex - 2 ] == '\xA0' ))
      count = 2;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    else if (( ch == '^' ) || ( ch == '~' ) || ( ch == '%' ))
      count = 2;

    // Remove the affected text portion and adjust the caret position
    Text.String = Text.String.remove( caretIndex - count, count );
    caretIndex  = caretIndex - count;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign at the current caret position.
  $rect <220,360,420,400>
  slot onDeleteKey
  {
    // No signs following the caret -> Nothing to delete
    if ( caretIndex >= ( Text.String.length - 1 ))
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if ( ch == '%' )
      count = 2;

    // Is this a space sign? Usually space signs are eliminated by the
    // text view unless we use the non-breakable space sign \xA0. However,
    // to perform the text wrap, a silent break sign '^' is placed behind
    // the space sign. Consider the both signs '\xA0^' as a unit
    else if ( ch == '\xA0' )
      count = 2;

    // Remove the affected text fragment
    Text.String = Text.String.remove( caretIndex, count );

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the <new line> sign and to move the caret \
  // to the next row.
  $rect <220,320,420,360>
  slot onNewlineKey
  {
    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( '\n', caretIndex );
    caretIndex  = caretIndex + 1;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the sign which has been input by the user \
  // and to move the caret to the next column.
  $rect <220,280,420,320>
  slot onCharacterKey
  {
    var char   ch  = CharacterKeyHandler.CharCode;
    var string str = ch;

    // Precede all special control signs with the '%' escape sign. Otherwise
    // the user can't input nor see them
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '\xAD' ) || ( ch == '%' ))
      str = "%" + ch;

    // To avoid the elimination of space signs at the end of a wrapped row
    // use the non-breakable space signs mit the additional 'silent' break
    // sign to perform the wrapping
    else if ( ch == ' ' )
      str = "\xA0^";

    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( str, caretIndex );
    caretIndex  = caretIndex + str.length;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  $rect <390,180,590,220>
  onset WrapText
  {
    // The value doesn't change - nothing to do.
    if ( pure WrapText == value )
      return;

    // Remember the new value ...
    pure WrapText = value;
    Text.WrapText = value;

    // If the text is warp automatically in rows, there is no need to
    // scroll the text horizontally.
    SlideTouchHandler.SlideHorz = !value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <190,180,390,220>
  onset Alignment
  {
    // The value doesn't change - nothing to do.
    if ( pure Alignment == value )
      return;

    // The justified mode is not supported by the editor.
    if ( value.contains( Views::TextAlignment[ AlignHorzJustified ]))
      value = value - Views::TextAlignment[ AlignHorzJustified ]
                    + Views::TextAlignment[ AlignHorzLeft ];

    // Remember the new value ...
    pure Alignment = value;
    Text.Alignment = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <590,90,790,130>
  onget String
  {
    // Get the current text view content
    var string str = Text.String;

    // In the following steps remove any special text view control signs
    // which are usually used to control the text flow. The resulting string
    // should contain the 'pure' text only.
    var int32  inx = str.find( '\xA0', 0 );

    // Internally the text editor works with the sign sequence '\xA0^' as
    // the space ' ' sign. This is because the text view tends to eliminate
    // regular space signs at the end of a text row.
    // Convert all '\xA0^' sign sequences to a regular space ' '
    while ( inx >= 0 )
    {
      if ( str[ inx + 1 ] == '^' )
      {
        str = str.remove( inx, 1 );
        str[ inx ] = ' ';
      }

      inx = str.find( '\xA0', inx + 1 );
    }

    inx = str.find( '%', 0 );

    // The special control/escape signs are not visible until there is a
    // '%' sign in front of them. Remove all superfluous '%' signs
    while ( inx >= 0 )
    {
      str = str.remove( inx, 1 );
      inx = str.find( '%', inx + 1 );
    }

    // Finally remove the <new line> sign at the end of text which was used
    // as workaround for a text flow parser issue
    return str.left( str.length - 1 );
  }

  $rect <590,50,790,90>
  onset String
  {
    // The value doesn't change - nothing to do.
    if ( pure String == value )
      return;

    // Remember the new string ...
    pure String = value;

    // In the following steps disarm in the assigned Unicode string the special
    // control and escape signs, which usually control the text flow in a  text
    // view. Without this conversion step, signs like '%' couldn't be seen in
    // the editor.
    var string str = value;
    var int32  inx = str.find( '%', 0 );

    // The special '%' escape sign is not visible until there is other
    // '%' sign in front of it. Convert all '%' signs into '%%' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '%', inx + 2 );
    }

    inx = str.find( '^', 0 );

    // The special '^' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '^' signs into '%^' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '^', inx + 2 );
    }

    inx = str.find( '~', 0 );

    // The special '~' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '~' signs into '%~' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '~', inx + 2 );
    }

    inx = str.find( '\xAD', 0 );

    // The special '\xAD' hyphen sign is not visible until there is a '%'
    // sign in front of it. Convert all '\xAD' hyphen signs into '%\xAD'
    // sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '\xAD', inx + 2 );
    }

    inx = str.find( ' ', 0 );

    // The text view tends to eliminate space signs at the end of a text row.
    // To avoid it, the editor will work internally with the non-breakable
    // space \xA0 sign. To perform the line wrap, an additional '^' silent
    // break control sign is placed behind the non-breakable space.
    // Convert all ' ' space signs to '\xA0^' sequence
    while ( inx >= 0 )
    {
      str[ inx ] = '\xA0';
      str = str.insert( "^", inx + 1 );
      inx = str.find( ' ', inx + 2 );
    }

    // Ensure that the caret still refers to a sign within the string
    if ( caretIndex > str.length )
      caretIndex = str.length;

    // Now show the new string in the editor's text view. The additional
    // <new line> is a workaround for a flow text parser issue
    Text.String = str + "\n";

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <390,50,590,90>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Store the new Color
    pure Color  = value;
    Text.Color  = value;
    Caret.Color = value;
  }

  $rect <190,50,390,90>
  onset Font
  {
    // The value doesn't change - nothing to do.
    if ( pure Font == value )
      return;

    // Store the new font...
    pure Font = value;
    Text.Font = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  // This bool change effect is used to blink the caret.
  $rect <20,580,220,620>
  object Effects::BoolEffect blinkEffect
  {
    preset Value2 = false;
    preset Value1 = true;
    preset Outlet = ^Caret.Visible;
    preset CycleDuration = 500;
    preset InterCycleDelay = 500;
  }

  // This key handler reacts to user inputs if the user has pressed the 'up', 'down', \
  // 'left' or 'right' key. In this case the associated onCursorKey method is called.
  $rect <20,440,220,480>
  object Core::KeyPressHandler CursorKeyHandler
  {
    preset OnPress = onCursorKey;
    preset Filter = Core::KeyCode.CursorKeys;
    preset OnHold = onCursorKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'backspace' \
  // key. In this case the associated onBackspaceKey method is called.
  $rect <20,400,220,440>
  object Core::KeyPressHandler BackspaceKeyHandler
  {
    preset OnPress = onBackspaceKey;
    preset Filter = Core::KeyCode.Backspace;
    preset OnHold = onBackspaceKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'delete' \
  // key. In this case the associated onDeleteKey method is called.
  $rect <20,360,220,400>
  object Core::KeyPressHandler DeleteKeyHandler
  {
    preset OnPress = onDeleteKey;
    preset Filter = Core::KeyCode.Delete;
    preset OnHold = onDeleteKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'enter' key. \
  // In this case the associated onNewlineKey method is called.
  $rect <20,320,220,360>
  object Core::KeyPressHandler NewlineKeyHandler
  {
    preset OnPress = onNewlineKey;
    preset Filter = Core::KeyCode.Enter;
    preset Enabled = false;
    preset OnHold = onNewlineKey;
  }

  // This key handler reacts to user inputs if the user has pressed a key corresponding \
  // to character/digit. In this case the associated onCharacterKey method is called.
  $rect <20,280,220,320>
  object Core::KeyPressHandler CharacterKeyHandler
  {
    preset OnPress = onCharacterKey;
    preset Filter = Core::KeyCode.CharacterKeys;
    preset OnHold = onCharacterKey;
  }

  // This slide gesture handler is used to scroll the text content.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,160,120>;
    preset SlideHorz = false;
    preset Friction = 0.05;
  }

  // This generic touch handler is used to move the caret.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,120>;
    preset Point3 = <160,120>;
    preset Point2 = <160,0>;
    preset Point1 = <0,0>;
    preset OnDrag = onDragTouch;
    preset OnHold = onHoldTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset MaxStrikeCount = 3;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <2,2,157,117>;
    preset OnUpdate = updateCaret;
    preset SlideHandler = SlideTouchHandler;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text\n";
    preset Font = Resources::FontVerdana24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Caret
  {
    preset Point2 = <50,70>;
    preset Point1 = <50,50>;
    preset Width2 = 2;
    preset Width1 = 2;
    preset Color = #000000FF;
    preset Visible = false;
  }

  // The property 'OnChange' can refer to a slot method, which should be invoked \
  // by the text editor when the user modifies the text.
  $rect <590,140,790,180>
  property slot OnChange = null;

  // The property 'WrapText' determines whether long text rows should be wrapped \
  // automatically.
  $rect <390,140,590,180>
  property bool WrapText = true;

  // The property 'Alignment' determines how the editor should display the text rows \
  // if their size differ from the size of the editor. 
  // In this manner the rows can be aligned horizontally. The entire text block can \
  // be aligned vertically.
  $rect <190,140,390,180>
  property Views::TextAlignment Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];

  // The property 'String' stores the text of the editor.
  $rect <590,10,790,50>
  property string String = "Text";

  // The property 'Color' controls the color of the text.
  $rect <390,10,590,50>
  property color Color = #000000FF;

  // The property 'Font' refers to the font object used to display the text. The \
  // text is determined by the property @String.
  $rect <190,10,390,50>
  property Resources::Font Font = Resources::FontVerdana24;
}

// This component implements a virtual keyboard.
$rect <560,400,760,440>
$output false
class NumKeyboard : Templates::NumKeyboard
{
  $rect <250,370,450,410>
  inherited property Bounds = <0,0,170,180>;

  $rect <480,250,680,290>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the affected keyboard.
    //
    // isKeyView --> the 'text' or 'image' view representing the pressed key.
    // isPressed --> the affected key should appear pressed.
    //
    var Core::View isKeyView = null;
    var bool       isPressed = ( TouchHandler.Down && TouchHandler.Inside ) || 
                                 FlashTimer.Enabled;

    // Search for the view representing the key at the recent touch position.
    // Do this however only when the position is valid - it lies inside the
    // area where keys are found (here the area of the TouchHandler) and the
    // key should appear pressed (isPressed == true)
    if ( isPressed && ( recentPosition == TouchHandler.GetExtent()))
      isKeyView = FindViewAtPosition( null, recentPosition, Core::ViewState[]);

    /*
       In this template, the keys are represented by simple 'text' and 'image'
       views. Any other view is considered as not corresponding to a key. Thus
       ignore every view, which is not an instance of 'text' or 'image'.
     
       TO DO:

       If you are using other views (not image nor text) to represent the keys,
       adapt the object runtime cast operations in the condition below to react
       on your particular views only. After this condition, 'isKeyView' should
       be either 'null' if the user is not pressing a key or it should refer to
       the view which represents the affected key.
    */

    if (((Views::Text)isKeyView == null ) && ((Views::Image)isKeyView == null ))
      isKeyView = null;

    /*

      TO DO:

      Depending on your keyboard design, you have surely added some new views
      to your keyboard. In the below code you should update the properties of
      these views. For example, when the user drags the finger between two keys
      one key should appear pressed while the other released.

      Whether the user has pressed/released a key can be estimated by comparing
      the variable 'isKeyView' with 'keyView'. If they differ, the user has
      pressed/released a key.

        if ( isKeyView != keyView )
          ...

      In practice, the variable 'isKeyView' represents the just pressed key.
      Your implementation should thus ensure, that the affected key appears
      pressed. If the user is not pressing any key, the variable is 'null'.

      The variable 'keyView' represents the key pressed in the preceding
      interaction. This key has thus to appear released. If there was no key
      pressed, the variable is 'null'.

      In the simplest case you modify the properties of the affected views, so
      they reflect their new state. Please note, the variables 'isKeyView' and
      'keyView' are declared with the generic Core::View class. In order to
      modify view specific properties you have to apply an object runtime cast
      operation on them. For example, if you are using 'text' views to represent
      keys, cast the variable to (Views::Text).

        if ( isKeyView != null )
          ((Views::Text)isKeyView).Color = color for a pressed key

        if ( keyView != null )
          ((Views::Text)keyView).Color = color for a released key

      Or you use, as demonstrated below, another views to highlight the area
      occupied by the affected key. For example, arrange some 'border' view
      to appear at the position of the pressed key with additional 5 pixel 
      padding:

        if ( isKeyView != null )
          BorderView.Bounds = isKeyView.GetExtent() * <5,5>;

      HINT:

      Instead of instantly alternate the views properties you can also start
      here effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the keyboard
      (e.g. 'isKeyView') with its preceding state (e.g. variable 'keyView').

      Assuming you have already added to your keyboard component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image lying behind the pressed key. Then following is 
      sufficient to trigger the animation:

        if (( isKeyView != null ) && ( keyView == null ))
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if (( isKeyView == null ) && ( keyView != null ))
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    // Detect a state alternation when the user presses a new or releases a
    // previously pressed key.
    if ( isKeyView != keyView )
    {
      var Views::Text isTextKeyView = (Views::Text)isKeyView;
      var Views::Text textKeyView   = (Views::Text)keyView;

      // If the user is actually pressing a key, arrange the background view
      // just behind the affected key view so it appears selected. If no key
      // is pressed, the background should disappear.
      if ( isKeyView != null )
      {
        Highlight.Bounds  = isKeyView.GetExtent();
        Highlight.Visible = true;
      }
      else
        Highlight.Visible = false;

      // If the user has pressed a key represented by a 'text' view, change the
      // color of the text to appear highlighted.
      if ( isTextKeyView != null )
        isTextKeyView.Color = #FFFFFFFF;

      // If the user has released a key represented by a 'text' view, restore
      // the color of the text.
      if ( textKeyView != null )
        textKeyView.Color = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    keyView = isKeyView;
  }

  // To do:
  // 
  // - Adjust the visible size of your keyboard (the thick blue border). This will \
  // be the keyboard's default size.
  // - Resize and arrange the member 'TouchHandler' so it covers the area where you \
  // intend to place the keys.
  // - Remove the 'Background' and 'Border' members if you want other views to be \
  // shown instead these in your keyboard.
  // - In this template, the individual keys are represented by text views 'TextKey0' \
  // .. 'TextKey9'.
  // - Special keys like the 'clear' and 'enter' key are represented by image views \
  // 'ImageKeyClear' and 'ImageKeyEnter'.
  // - Remove the above described 'text' and 'image' views if you don't want them.
  // - Add more 'text' and 'image' views to represent more keys.
  // - Arrange the 'text' and 'image' views within the area of the 'TouchHandler'. \
  // The position of a view determine the area of the corresponding key.
  // - According to your desired keyboard design add and configure new decoration \
  // views (e.g. an image view to show some icon, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the keyboard's current state.
  // - Adapt the implementation of the 'activateKey' slot method. This method evaluates \
  // which key the user has pressed and feeds the corresponding key event to the \
  // application.
  // - You can also add and configure animation effects to your keyboard. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the keyboard itself is resized.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your keyboard. One property \
  // for every keyboard specific setting (e.g. 'Caption', 'Color', 'Font', ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Font' should update the key related 'text' views in your \
  // component).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note4
  {
    attr Bounds = <10,430,990,890>;
  }

  // State management
  note group Note3
  {
    attr Bounds = <470,210,690,380>;
  }

  // Feedback flash effect
  note group Note2
  {
    attr Bounds = <240,210,460,340>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,210,230,420>;
  }

  // This variable refers to the view representing the actually pressed key or it \
  // is 'null' if the user is not touching a key.
  $rect <480,330,680,370>
  var Core::View keyView;

  // This variable stores the recent position inside the keyboard area where the \
  // user is touching the screen.
  $rect <20,370,220,410>
  var point recentPosition;

  // This timer object is used to flash the pressed key when the user has tapped \
  // it very quickly. This is just a visual feedback effect.
  $rect <250,250,450,290>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This internal slot method is called when the recently pressed key should be \
  // activated. This is when the user presses on a key and then releases the finger \
  // again.
  $rect <480,290,680,330>
  slot activateKey
  {
    // Applying the object runtime casting test whether the user is
    // touching a key with 'text' caption.
    var Views::Text textKeyView = (Views::Text)keyView;

    // Depending on the pressed key, the following variables will be
    // initialized with the corresponding code.
    var char          charCode = '\0';
    var Core::KeyCode keyCode  = Core::KeyCode.NoKey;

    // Has the user touched (activated) one of the keys with text
    // as caption? Use the text as character code to feed the application 
    // with a keyboard event.
    if ( textKeyView != null )
      charCode = textKeyView.String[0];

    // Has the user touched the 'Enter' key?
    else if ( keyView == ImageKeyEnter )
      keyCode = Core::KeyCode.Enter;

    // Has the user touched the 'Clear' key?
    else if ( keyView == ImageKeyClear )
      keyCode = Core::KeyCode.Backspace;

    // The user has pressed a regular character/digit key. Feed it as keyboard
    // event to the application.
    if ( charCode != '\0' )
    {
      GetRoot().DriveKeyboardHitting( Core::KeyCode.NoKey, charCode, true );
      GetRoot().DriveKeyboardHitting( Core::KeyCode.NoKey, charCode, false );
    }

    // The user has pressed a special key (e.g. Enter). Feed it as keyboard
    // event to the application.
    if ( keyCode != Core::KeyCode.NoKey )
    {
      GetRoot().DriveKeyboardHitting( keyCode, '\0', true );
      GetRoot().DriveKeyboardHitting( keyCode, '\0', false );
    }
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <250,290,450,330>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the keyboard to update 
    // its appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the key is activated.
    signal activateKey;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the keyboard. This updates the keyboard to highlight the key at the new touch \
  // position.
  $rect <20,330,220,370>
  slot onDragTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    // Remember the new position where the user recently touched the screen
    recentPosition = TouchHandler.CurrentPos;
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the keyboard area. This activates the key the user has touched.
  $rect <20,290,220,330>
  slot onReleaseTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    // Did the user moved the finger outside the keyboard's area? In such case
    // the keyboard is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user has pressed and held a key for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The keyboard can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      signal activateKey;

    // The user has tapped the keyboard very quickly. Defer the key activation
    // to give the user first a short visual feedback that the key has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the keyboard area.
  $rect <20,250,220,290>
  slot onPressTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    // The keyboard is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the keyboard in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new key interaction.
    if ( FlashTimer.Enabled )
    {
      signal activateKey;
      FlashTimer.Enabled = false;
    }

    // Remember the new position where the user has touched the screen
    recentPosition = TouchHandler.CurrentPos;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,170,180>;
    preset Color = Application::BackgroundColor;
  }

  // This is a border view.
  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,170,180>;
    preset Width = 3;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <10,170>;
    preset Point3 = <160,170>;
    preset Point2 = <160,10>;
    preset Point1 = <10,10>;
    preset OnDrag = onDragTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset EnableMultiTouch = true;
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Highlight
  {
    preset Bounds = <10,10,60,50>;
    preset Color = #4C4C4AFF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,10,60,50>;
    preset String = "1";
    preset Font = Resources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey2
  {
    preset Layout = Core::Layout[AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <60,10,110,50>;
    preset String = "2";
    preset Font = Resources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey3
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <110,10,160,50>;
    preset String = "3";
    preset Font = Resources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey4
  {
    preset Layout = Core::Layout[AlignToLeft, ResizeHorz, ResizeVert];
    preset Bounds = <10,50,60,90>;
    preset String = "4";
    preset Font = Resources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey5
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <60,50,110,90>;
    preset String = "5";
    preset Font = Resources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey6
  {
    preset Layout = Core::Layout[AlignToRight, ResizeHorz, ResizeVert];
    preset Bounds = <110,50,160,90>;
    preset String = "6";
    preset Font = Resources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey7
  {
    preset Layout = Core::Layout[AlignToLeft, ResizeHorz, ResizeVert];
    preset Bounds = <10,90,60,130>;
    preset String = "7";
    preset Font = Resources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey8
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <60,90,110,130>;
    preset String = "8";
    preset Font = Resources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey9
  {
    preset Layout = Core::Layout[AlignToRight, ResizeHorz, ResizeVert];
    preset Bounds = <110,90,160,130>;
    preset String = "9";
    preset Font = Resources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey0
  {
    preset Layout = Core::Layout[AlignToBottom, ResizeHorz, ResizeVert];
    preset Bounds = <60,130,110,170>;
    preset String = "0";
    preset Font = Resources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyClear
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, ResizeHorz, ResizeVert];
    preset Bounds = <10,130,60,170>;
    preset FrameNumber = 1;
    preset Bitmap = Resources::KeyBackspace;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyEnter
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, ResizeHorz, ResizeVert];
    preset Bounds = <110,130,160,170>;
    preset FrameNumber = 1;
    preset Bitmap = Resources::KeyEnter;
    preset Visible = true;
  }
}

// Resources
note group Note
{
  attr Bounds = <460,540,1150,990>;
}

$rect <610,200,810,240>
$output false
class WellLabel : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,70,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,70,40>;
    preset String = "A";
    preset Font = Flat::FontL;
    preset Color = #000000FF;
  }

  $rect <300,0,500,40>
  property string TextString = "A";

  $rect <300,40,500,80>
  onset TextString
  {
    // The value doesn't change - nothing to do.
    if ( pure TextString == value )
      return;

    // Remember the property's new value.
    pure TextString = value;
    Text.String=TextString;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <300,80,500,120>
  onget TextString
  {
    return pure TextString;
  }
}

$rect <150,250,350,290>
$output false
class Temperature : Core::Group
{
  $rect <0,300,200,340>
  inherited property Bounds = <0,0,130,60>;

  $rect <0,380,200,420>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,340,200,380>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <140,10,340,50>
  object Core::Timer Timer
  {
    preset OnTrigger = onEvent;
    preset Period = 1000;
    preset Enabled = true;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,130,60>;
    preset String = "25C";
    preset Font = Flat::FontXL;
  }

  $rect <90,120,290,160>
  object Core::PropertyObserver PropertyObserver
  {
    preset OnEvent = onEvent;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <290,120,490,160>
  slot onEvent
  {
    /*
    var int32 aNum  =0 ;

    native (aNum) {

    	int file_i2c;
    	int length;
    	unsigned char buffer[60] = {0};
          
            
    	//----- OPEN THE I2C BUS -----
    	char* filename = (char*)"/dev/i2c-1";
    	if ((file_i2c = open(filename, O_RDWR)) < 0)
    	{
    		//ERROR HANDLING: you can check errno to see what went wrong
    		printf("Failed to open the i2c bus");
    		return;
    	}
    	
    	int addr = (0x4f);          //<<<<<The I2C address of the slave
    	if (ioctl(file_i2c, I2C_SLAVE, addr) < 0)
    	{
    		printf("Failed to acquire bus access and/or talk to slave.\n");
    		//ERROR HANDLING; you can check errno to see what went wrong
    		return;
    	}
    	
                //----- READ BYTES -----
                length = 1;			//<<< Number of bytes to read
                if (read(file_i2c, buffer, length) != length)		//read() returns the number of bytes actually read, if it doesn't match then an error occurred (e.g. no response from the device)
                {                                                                                                    
                        //ERROR HANDLING: i2c transaction failed
                        //printf("Failed to read from the i2c bus.\n");
                }
                else
                {
                         aNum = buffer[0];
                }
    }


    Device::Device.Temperature=aNum;
    */

    Text.String=string(Device::Device.Temperature)+"C";

  }
}

$rect <120,400,320,440>
$output false
class Config : Core::Group
{
  $rect <10,540,210,580>
  inherited property Bounds = <0,0,800,480>;

  $rect <10,620,210,660>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,580,210,620>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,480>;
    preset Color = Application::BackgroundColor;
  }

  $rect <20,20,160,60>
  object Application::AActionButton Btn_Ok
  {
    preset Bounds = <670,440,790,470>;
    preset Enabled = false;
    preset OnAction = onBtn_Ok;
    preset Caption = "OK";
  }

  $rect <870,290,1070,330>
  slot onBtn_Ok
  {
    /*if(TextEditor.String.parse_int32(6)>6||TextEditor.String.parse_int32(6)<1){
      Device::Device.NuOfCircuits=6;
      trace "ERROR: Not allowed Number of Circuits";
    }else{
      Device::Device.NuOfCircuits=TextEditor.String.parse_int32(6);
    }*/
    this.Enabled=false;
    this.Visible=false;
    ControllMenue.Enabled=true;



  }

  $rect <20,20,160,60>
  object Application::TextEditor TextEditor
  {
    preset Bounds = <330,110,470,170>;
    preset String = "6";
    preset Font = Flat::FontL;
  }

  $rect <20,20,160,60>
  object Application::NumKeyboard NumKeyboard
  {
    preset Bounds = <610,230,780,410>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <60,10,690,120>;
    preset WrapText = true;
    preset String = "Geben Sie die Anzahl der zu verwendenden Kreislufe ein (Zahl von 1 bis 6)";
    preset Font = Flat::FontL;
  }

  $rect <870,160,1070,200>
  property Application::ControllMenu ControllMenue = null;

  $rect <870,200,1070,240>
  onset ControllMenue
  {
    // The value doesn't change - nothing to do.
    if ( pure ControllMenue == value )
      return;

    // Remember the property's new value.
    pure ControllMenue = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <870,240,1070,280>
  onget ControllMenue
  {
    return pure ControllMenue;
  }

  $rect <850,540,1050,580>
  slot onNextWaste
  {
    Device::Device.SetWastePosition( ConfigWaste.XSlider.CurrentValue, ConfigWaste.YSlider.CurrentValue, ConfigWaste.ZSlider.CurrentValue );

    ConfigWaste.Visible=false;
    ConfigWaste.Enabled=false;


  }

  $rect <850,580,1050,620>
  slot onNextTR
  {
    Device::Device.SetTRPosition( ConfigTR.XSlider.CurrentValue, ConfigTR.YSlider.CurrentValue, ConfigTR.ZSlider.CurrentValue );

    ConfigTR.Visible=false;
    ConfigTR.Enabled=false;
  }

  $rect <850,620,1050,660>
  slot onNextBL
  {
    Device::Device.SetBLPosition( ConfigBL.XSlider.CurrentValue, ConfigBL.YSlider.CurrentValue, ConfigBL.ZSlider.CurrentValue );

    ConfigBL.Visible=false;
    ConfigBL.Enabled=false;
  }

  $rect <20,20,160,60>
  object Application::ConfigPosition ConfigTop
  {
    preset Bounds = <0,0,800,480>;
    preset onNext = onNextTop;
    preset Title = "Bewegen sie den Schlauch so hoch, damit er die Khlvorrichtung nicht berhrt";
    preset Help = Application::ConfigTop;
  }

  $rect <20,20,160,60>
  object Application::ConfigPosition ConfigTR
  {
    preset Bounds = <0,0,800,480>;
    preset onNext = onNextTR;
    preset Title = "Bewegen Sie den Schluch ber die Well ffnung rechts hinten";
    preset Help = Application::ConfigTR;
  }

  $rect <20,20,160,60>
  object Application::ConfigPosition ConfigBL
  {
    preset Bounds = <0,0,800,480>;
    preset onNext = onNextBL;
    preset Title = "Bewegen Sie den Schluch ber die Well ffnung links vorne";
    preset Help = Application::ConfigBL;
  }

  $rect <20,20,160,60>
  object Application::ConfigPosition ConfigWaste
  {
    preset Bounds = <0,0,800,480>;
    preset Visible = true;
    preset onNext = onNextWaste;
    preset Title = "Bewegen Sie den Schlauch ber den Waste Behlter";
    preset Help = Application::ConfigWaste;
  }

  $rect <850,660,1050,700>
  slot onNextTop
  {
    Device::Device.SetTopPosition( ConfigBL.XSlider.CurrentValue, ConfigBL.YSlider.CurrentValue, ConfigBL.ZSlider.CurrentValue );

    ConfigTop.Visible=false;
    ConfigTop.Enabled=false;
    Btn_Ok.Enabled=true;
  }
}

$rect <150,440,350,480>
$output false
class ConfigPosition : Core::Group
{
  $rect <10,540,210,580>
  inherited property Bounds = <0,0,800,480>;

  $rect <10,620,210,660>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,580,210,620>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,480>;
    preset Color = Application::BackgroundColor;
  }

  $rect <20,20,160,60>
  object Application::AActionButton Btn_Next
  {
    preset Bounds = <670,440,790,470>;
    preset Enabled = false;
    preset OnAction = onBtnNext;
    preset Caption = "Next";
  }

  $rect <20,20,160,60>
  object Views::Text TextTitle
  {
    preset Bounds = <60,10,690,120>;
    preset WrapText = true;
    preset String = "Beispiel Text";
    preset Font = Flat::FontL;
  }

  $rect <20,20,160,60>
  object Application::AHorzSlider XSlider
  {
    preset Bounds = <60,240,780,310>;
    preset CurrentValue = 0;
    preset OnChange = OnChangePos;
  }

  $rect <20,20,160,60>
  object Application::AHorzSlider YSlider
  {
    preset Bounds = <60,310,780,370>;
    preset CurrentValue = 0;
    preset OnChange = OnChangePos;
  }

  $rect <830,340,1030,380>
  slot OnChangePos
  {
    Device::Device.SetCurrentPosition( XSlider.CurrentValue, YSlider.CurrentValue, ZSlider.CurrentValue );
    Btn_Next.Enabled=true;

  }

  $rect <20,20,160,60>
  object Application::AHorzSlider ZSlider
  {
    preset Bounds = <60,370,780,430>;
    preset CurrentValue = 0;
    preset OnChange = OnChangePos;
  }

  $rect <830,20,1030,60>
  property slot onNext = null;

  $rect <830,60,1030,100>
  onset onNext
  {
    // The value doesn't change - nothing to do.
    if ( pure onNext == value )
      return;

    // Remember the property's new value.
    pure onNext = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <830,100,1030,140>
  onget onNext
  {
    return pure onNext;
  }

  $rect <830,160,1030,200>
  property string Title = "";

  $rect <830,200,1030,240>
  onset Title
  {
    // The value doesn't change - nothing to do.
    if ( pure Title == value )
      return;

    // Remember the property's new value.
    pure Title = value;

    TextTitle.String=Title;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <830,240,1030,280>
  onget Title
  {
    return pure Title;
  }

  $rect <830,300,1030,340>
  slot onBtnNext
  {
    signal onNext;
  }

  $rect <20,20,160,60>
  object Views::Text TextX
  {
    preset Bounds = <10,250,50,300>;
    preset WrapText = true;
    preset String = "X";
    preset Font = Flat::FontL;
  }

  $rect <20,20,160,60>
  object Views::Text TextY
  {
    preset Bounds = <10,310,50,360>;
    preset WrapText = true;
    preset String = "Y";
    preset Font = Flat::FontL;
  }

  $rect <20,20,160,60>
  object Views::Text TextZ
  {
    preset Bounds = <10,370,50,420>;
    preset WrapText = true;
    preset String = "Z";
    preset Font = Flat::FontL;
  }

  $rect <1070,30,1270,70>
  property Resources::Bitmap Help = null;

  $rect <1070,70,1270,110>
  onset Help
  {
    // The value doesn't change - nothing to do.
    if ( pure Help == value )
      return;
    Img_Help.Bitmap=value;
    // Remember the property's new value.
    pure Help = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <1070,110,1270,150>
  onget Help
  {
    return pure Help;
  }

  $rect <20,20,160,60>
  object Application::AToggleButton Btn_Help
  {
    preset Bounds = <550,440,650,470>;
    preset OnChange = onBtn_Help;
    preset Caption = "Help";
  }

  $rect <1100,240,1300,280>
  slot onBtn_Help
  {
    if(Btn_Help.Active){
      Img_Help.Visible=true;
    }else{
      Img_Help.Visible=false;
    }
  }

  $rect <20,20,160,60>
  object Views::Image Img_Help
  {
    preset Bounds = <10,10,790,430>;
    preset Bitmap = null;
    preset Visible = false;
  }
}

$rect <120,210,320,250>
$output false
class ControllMenu : Core::Group
{
  $rect <10,600,210,640>
  inherited property Bounds = <0,0,800,480>;

  $rect <10,560,210,600>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,520,210,560>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,480>;
    preset Color = Application::BackgroundColor;
  }

  $rect <20,20,160,60>
  object Application::SampleController SCA
  {
    preset Bounds = <10,50,450,120>;
    preset NameProperty = '1';
  }

  $rect <20,20,160,60>
  object Application::SampleController SCA1
  {
    preset Bounds = <10,120,450,190>;
    preset NameProperty = '2';
  }

  $rect <20,20,160,60>
  object Application::SampleController SCA2
  {
    preset Bounds = <10,190,450,260>;
    preset NameProperty = '3';
  }

  $rect <20,20,160,60>
  object Application::SampleController SCA3
  {
    preset Bounds = <10,260,450,330>;
    preset NameProperty = '4';
  }

  $rect <20,20,160,60>
  object Application::SampleController SCA4
  {
    preset Bounds = <10,330,450,400>;
    preset NameProperty = '5';
  }

  $rect <20,20,160,60>
  object Application::SampleController SCA5
  {
    preset Bounds = <10,400,450,470>;
    preset NameProperty = '6';
  }

  $rect <20,20,160,60>
  object Application::Clock Clock
  {
    preset Bounds = <670,410,790,470>;
  }

  $rect <20,20,160,60>
  object Views::WarpImage Logo
  {
    preset Point4 = <700,110>;
    preset Point3 = <800,110>;
    preset Point2 = <800,10>;
    preset Point1 = <700,10>;
    preset Bitmap = Application::Logo;
  }

  $rect <20,20,160,60>
  object Application::NumKeyboard NumKeyboard
  {
    preset Bounds = <460,290,660,470>;
  }

  $rect <20,20,160,60>
  object Application::Temperature Temperature
  {
    preset Bounds = <660,330,800,390>;
  }

  $rect <840,100,1040,140>
  object Core::PropertyObserver NuOfCircuitsObserver
  {
    preset OnEvent = onNuOfCircuits;
    preset Outlet = ^Device::Device.NuOfCircuits;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <1040,100,1240,140>
  slot onNuOfCircuits
  {
    var int32 i;
    for(i=0;i<6;i=i+1){
      SampleController[i].Visible=false;
      SampleController[i].Enabled=false;
    }

    for(i=0;i<Device::Device.NuOfCircuits;i=i+1){
      SampleController[i].Visible=true;
      SampleController[i].Enabled=true;
    }

  }

  $rect <840,60,1040,100>
  array Application::SampleController SampleController[ 6 ] =
  (
    Default[0] = SCA;
    Default[1] = SCA1;
    Default[2] = SCA2;
    Default[3] = SCA3;
    Default[4] = SCA4;
    Default[5] = SCA5;
  );

  $rect <20,20,160,60>
  object Application::AActionButton Btn_Config
  {
    preset Bounds = <480,140,600,170>;
    preset OnAction = onBtn_Config;
    preset Caption = "Config";
  }

  $rect <830,190,1030,230>
  slot onBtn_Config
  {
    Config.ConfigBL.Visible=true;
    Config.ConfigTR.Visible=true;
    Config.ConfigWaste.Visible=true;
    Config.Visible=true;

    Config.ConfigBL.Enabled=true;
    Config.ConfigTR.Enabled=true;
    Config.ConfigWaste.Enabled=true;
    Config.Enabled=true;

    this.Enabled=false;

    Config.Bounds.x1=0;
    Config.Bounds.y1=0;
  }

  $rect <20,20,160,60>
  object Application::AActionButton Btn_NewWell
  {
    preset Bounds = <480,180,600,210>;
    preset OnAction = onBtn_NewWell;
    preset Caption = "NewWell";
  }

  $rect <830,230,1030,270>
  slot onBtn_NewWell
  {
    Device::Device.NewWell=true;
  }

  $rect <830,320,1030,360>
  property Application::Config Config = null;

  $rect <830,360,1030,400>
  onset Config
  {
    // The value doesn't change - nothing to do.
    if ( pure Config == value )
      return;

    // Remember the property's new value.
    pure Config = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <830,400,1030,440>
  onget Config
  {
    return pure Config;
  }

  $rect <20,20,160,60>
  object Application::AActionButton Btn_StopAll
  {
    preset Bounds = <480,220,600,250>;
    preset Caption = "StopAll";
  }

  $rect <370,500,570,540>
  object Core::SystemEventHandler RemainingTime
  {
    preset OnEvent = onRemainingTime;
    preset Event = Device::Device.RemainingTimeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <570,500,770,540>
  slot onRemainingTime
  {
    var Device::RemainingTimeContext context = (Device::RemainingTimeContext)RemainingTime.Context;
    SampleController[context.CircuitNumber].RemainingTime=context.RemainingTime;

  }
}

// Tab1: MainMenu
note group Note2
{
  attr Bounds = <20,90,420,530>;
}

// ControllMenu
note group Note3
{
  attr Bounds = <100,170,360,350>;
}

// Config
note group Note4
{
  attr Bounds = <100,360,360,510>;
}

// Tab2: Well
note group Note5
{
  attr Bounds = <460,90,870,300>;
}

// Other Components
note group Note6
{
  attr Bounds = <460,310,1150,530>;
}

note arrow Note1
{
  attr Point1 = <320,90>;
  attr Point2 = <370,50>;
}

note arrow Note7
{
  attr Point1 = <610,90>;
  attr Point2 = <550,50>;
}

// Horizontal bar widget with a flat design. The widget is used to illustrate a value \
// by using a colored horizontal bar, e.g. like a progress bar.
$rect <560,480,760,520>
$output false
class AHorzBar : Core::Group
{
  $rect <0,220,180,260>
  inherited method UpdateViewState()
  {
    aState;
    var int32 pos = 0;

    /* ensure that the current set value and the given minimum and maximum values are valid */
    if (( MaxValue > MinValue ) && ( CurrentValue >= MinValue ) && ( CurrentValue <= MaxValue ))
    {
      /* calculate the center position of the thumb within the slider area */
      pos = Bounds.w * ( CurrentValue - MinValue ) / ( MaxValue - MinValue );
    }

    /* update the text item for current value */
    if ( pure ShowCurrent )
      BarText.String = formatValueString( pure CurrentValue )+"min";
    BarText.Visible = pure ShowCurrent;

    /* arrange the bar and text item according bar width */
    Rectangle.Bounds.h = pure BarSize;
    Bar.Bounds.h = pure BarSize;
    BarText.Bounds.origin.y = pure BarSize + 2;

    /* if calculated position is different from the current bar, let's start an animation to move the bar smooth */
    if ( pos != Bar.Bounds.w )
    {
      /* stop currently running animation */
      MoveBarEffect.Enabled = false;

      /* calculate a start value that is 1/10 into the final direction */
      Bar.Bounds.w = ( Bar.Bounds.w * 9 + pos ) / 10;

      /* start animation of bar */
      MoveBarEffect.Value1  = Bar.Bounds.w;
      MoveBarEffect.Value2  = pos;
      MoveBarEffect.Enabled = true;
    }




  }

  $rect <0,180,180,220>
  inherited property Bounds = <0,0,160,50>;

  // The property 'MinValue' defines the lower boundary of the widgets value range.
  $rect <370,0,550,40>
  property int32 MinValue = 0;

  $rect <370,40,550,80>
  onset MinValue
  {
    /* check if the given value differs from the current value */
    if ( pure MinValue == value )
      return;

    /* store the new value */
    pure MinValue = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // The property 'MaxValue' defines the upper boundary of the widgets value range.
  $rect <550,0,730,40>
  property int32 MaxValue = 100;

  $rect <550,40,730,80>
  onset MaxValue
  {
    /* check if the given value differs from the current value */
    if ( pure MaxValue == value )
      return;

    /* store the new value */
    pure MaxValue = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // The property 'CurrentValue' stores the momentary value of the widget. The value \
  // is limited automatically to the range from @MinValue to @MaxValue.
  $rect <190,0,370,40>
  property int32 CurrentValue = 50;

  $rect <190,40,370,80>
  onset CurrentValue
  {
    /* limit the given value to the range between MinValue and MaxValue */
    if ( value < MinValue )
      value = MinValue;
    if ( value > MaxValue )
      value = MaxValue;

    /* check if the given value differs from the current value */
    if ( pure CurrentValue == value )
      return;

    /* store the new value */
    pure CurrentValue = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <190,180,370,220>
  slot outletSlot
  {
    /* update the current state of the widget */
    if ( Outlet != null )
      CurrentValue = Outlet^;
  }

  $rect <190,130,370,170>
  onset Outlet
  {
    /* check if the new outlet differs from the currently used outlet */
    if ( pure Outlet == value )
      return;

    /* detach from the previous outlet */
    detachobserver outletSlot, pure Outlet;

    /* store the new outlet */
    pure Outlet = value;

    /* ... and attach to the new one */
    attachobserver outletSlot, value;

    /* finally, update the current state of the widget by posting a signal to the outlet slot */
    if ( value != null )
      postsignal outletSlot;
  }

  // The property 'Outlet' provides an interface for the Controller-View model. In \
  // the Controller-View model, the widgets (views) and the application logic (controllers) \
  // are always kept apart. An automatism behind this model ensures, that widgets \
  // are notified automatically as soon as the affected controller has changed its \
  // state. On the other hand, user interactions on a widget cause the affected controller \
  // to execute the application logic. Usually, a controller is a simple Chora object \
  // containing several properties and the implementation of onget/onset method.
  // By assigning a property reference, Outlet establishes a connection between the \
  // widget and the controller object, the affected property belongs to. After this, \
  // the widget is able to read and modify the referred property in response to the \
  // user interactions. It is also able to adapt the widget appearance, if the value \
  // of the referred property has been modified by another widget or by the application \
  // logic itself.
  $rect <190,90,370,130>
  property ^int32 Outlet = null;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <0,0,160,20>;
    preset Color = Flat::ColorOfBody;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Bar
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <0,0,90,20>;
    preset Color = Application::WidgetColor;
  }

  $rect <20,20,160,60>
  object Views::Text BarText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToTop];
    preset Bounds = <80,20,98,40>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "50";
    preset Font = Flat::FontS;
    preset Color = Application::WidgetColor;
  }

  $rect <190,300,370,340>
  object Effects::Int32Effect MoveBarEffect
  {
    preset NoOfCycles = 1;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset CycleDuration = 500;
    preset Outlet = ^barPos;
  }

  $rect <190,340,370,380>
  property int32 barPos = 0;

  $rect <190,380,370,420>
  onset barPos
  {
    pure barPos = value;

    /* set position of bar */
    Bar.Bounds.w = value;

    /* calculate position of bar text item */
    BarText.Bounds.origin.x = value - BarText.Bounds.w / 2;

    if ( BarText.Bounds.origin.x < 0 )
      BarText.Bounds.origin.x = 0;

    if ( BarText.Bounds.x2 > Bounds.w )
      BarText.Bounds.origin.x = Bounds.w - BarText.Bounds.w;


  }

  // The property 'ShowCurrent' controls the visibility of the text items displaying \
  // the current value.
  $rect <730,90,910,130>
  property bool ShowCurrent = true;

  $rect <730,130,910,170>
  onset ShowCurrent
  {
    /* store the new value */
    pure ShowCurrent = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  // The property 'DotPosition' stores the index of the digit where the dot is shown. \
  // In case that 'DotPosition' is zero, the dot disappears.
  $rect <370,90,550,130>
  property int32 DotPosition = 0;

  $rect <370,130,550,170>
  onset DotPosition
  {
    /* check if the given value differs from the current value */
    if ( pure DotPosition == value )
      return;

    /* check limits of the given value */
    if ( value < 0 )
      value = 0;
    if ( value > 3 )
      value = 3;

    /* store the new value */
    pure DotPosition = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // The property 'Divisor' stores the ratio for the display value.
  $rect <550,90,730,130>
  property int32 Divisor = 1;

  $rect <550,130,730,170>
  onset Divisor
  {
    /* check if the given value differs from the current value */
    if ( pure Divisor == value )
      return;

    /* check limits of the given value */
    if ( value < 1 )
      value = 1;
    if ( value > 1000 )
      value = 1000;

    /* store the new value */
    pure Divisor = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // Method to format a string based on the given aValue and the current @DotPosition \
  // and @Divisor.
  $rect <0,260,180,300>
  method string formatValueString( arg int32 aValue )
  {
    /* calculate the value to display */
    var int32 val = aValue / pure Divisor;
    var int32 abs = val;
    if ( val < 0 )
      abs = -val;

    /* format a string with decimal point if needed */
    if ( pure DotPosition == 1 )
      return string( val / 10, 1 ) + "." + string( abs % 10, 1 );
    else if ( pure DotPosition == 2 )
      return string( val / 100, 1 ) + "." + string( abs % 100, 2 );
    else if ( pure DotPosition == 3 )
      return string( val / 1000, 1 ) + "." + string( abs % 1000, 3 );

    return string( val );
  }

  // The property 'BarSize' defines the height of the bar in pixel.
  $rect <730,0,910,40>
  property int32 BarSize = Flat::BarSize;

  $rect <730,40,910,80>
  onset BarSize
  {
    /* check if the given value differs from the current value */
    if ( pure BarSize == value )
      return;

    /* check limits of the given value */
    if ( value < 0 )
      value = 0;

    /* store the new value */
    pure BarSize = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // The class 'HorzBar' implements a widget to illustrate a value by using an animated \
  // colored horizontal bar.
  // The property 'CurrentValue' represents the momentary value of the widget and \
  // corresponds to the position of the bar. The supported value range of the horizontal \
  // bar can be defined by setting the properties 'MinValue' and 'MaxValue'.
  // Optionally, the widget displays the current value as text. The properties 'DotPosition' \
  // and 'Divisor' can be used to configure the value text display.
  // A horizontal bar can be connected with an Int32 'Outlet' property to show the \
  // current value of this property.
  // The height of the horizontal bar can be configured via the property 'BarSize'.
  // Additionally, the colors of the widget can be configured individually by setting \
  // the properties 'BackColor', 'BarColor' and 'TextColor'.
  note legend Note
  {
    attr Bounds = <10,430,950,590>;
  }

  // The property 'BackColor' defines the background color of the widget. The property \
  // is used to assign a color independent from the current theme color.
  $rect <370,180,550,220>
  property color BackColor = Flat::ColorOfBody;

  $rect <370,220,550,260>
  onset BackColor
  {
    /* store the new value */
    pure BackColor = value;

    /* ...and colorize the affected members of the widget */
    Rectangle.Color  = value;



  }

  // The property 'BarColor' defines the color of the widgets indicator bar. The \
  // property is used to assign a color independent from the current theme color.
  $rect <550,180,730,220>
  property color BarColor = Application::WidgetColor;

  $rect <550,220,730,260>
  onset BarColor
  {
    /* store the new value */
    pure BarColor = value;

    /* ...and colorize the affected members of the widget */
    Bar.Color   = value;

  }

  // The property 'TextColor' defines the color of the widgets text members. The \
  // property is used to assign a color independent from the current theme color.
  $rect <730,180,910,220>
  property color TextColor = Application::WidgetColor;

  $rect <730,220,910,260>
  onset TextColor
  {
    /* store the new value */
    pure TextColor = value;

    /* ...and colorize the affected members of the widget */
    BarText.Color = value;

  }

  $reorder UpdateViewState 44
}

$rect <570,690,770,730>
$output false
resource Resources::Bitmap Coordinates
{
  attr bitmapfile FileName = .\Resources\coordinates.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <570,730,770,770>
$output false
resource Resources::Bitmap ConfigTR
{
  attr bitmapfile FileName = .\Resources\ConfigTR.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <570,770,770,810>
$output false
resource Resources::Bitmap ConfigBL
{
  attr bitmapfile FileName = .\Resources\ConfigBL.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <570,810,770,850>
$output false
resource Resources::Bitmap ConfigTop
{
  attr bitmapfile FileName = .\Resources\ConfigTop.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <570,850,770,890>
$output false
resource Resources::Bitmap ConfigWaste
{
  attr bitmapfile FileName = .\Resources\ConfigWaste.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <860,570,1070,610>
$output false
const color BackgroundColor = #8D8D8DFF;

$rect <860,610,1070,650>
$output false
const color WidgetColor = #FF9601FF;

// Action button widget with a flat design. The widget is used as a simple push button \
// with a text.
$rect <800,360,980,400>
$output false
class AActionButton : Core::Group
{
  $rect <0,90,180,130>
  inherited property Bounds = <0,0,120,30>;

  $rect <0,130,180,170>
  inherited method UpdateViewState()
  {
    /* colorize frame and text, depending on current state of the view */
    if ( aState.contains( Core::ViewState[ Enabled ]))
    {
      if ( TouchHandler.Down && TouchHandler.Inside )
        Frame.Color = ItemColorActive;
      else
        Frame.Color = ItemColor;
    }
    else
      Frame.Color = Flat::ColorOfDisabled;

  }

  // This internal slot method is used to receive the corresponding signals form \
  // the touch handler.
  $rect <0,180,180,220>
  slot enterLeaveSlot
  {
    InvalidateViewState();
  }

  // This internal slot method is used to receive the corresponding signals form \
  // the touch handler.
  $rect <0,220,180,260>
  slot pressReleaseSlot
  {
    /* releasing the finger outside the button area is ignored */
    if ( !TouchHandler.Down && TouchHandler.Inside )
    {
      /* inform the connected slot method */
      idlesignal OnAction;
    }
  }

  // The property 'OnAction' can refer to a slot method, which will receive a signal \
  // as soon the user has pressed the button. Thereupon the method's logic will be \
  // executed.
  $rect <190,90,370,130>
  property slot OnAction = null;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,30>;
    preset Point3 = <120,30>;
    preset Point2 = <120,0>;
    preset Point1 = <0,0>;
    preset OnLeave = enterLeaveSlot;
    preset OnEnter = enterLeaveSlot;
    preset OnRelease = pressReleaseSlot;
    preset OnPress = pressReleaseSlot;
  }

  $rect <20,20,160,60>
  object Views::Frame Frame
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,120,30>;
    preset Color = Flat::ColorOfTouch;
    preset Bitmap = Flat::FlatFrame;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,120,30>;
    preset String = "Button";
    preset Font = Flat::FontM;
    preset Color = Flat::ColorOfBackground;
  }

  $rect <190,40,370,80>
  onset Caption
  {
    pure Caption = value;
    CaptionText.String  = value;
  }

  // The property 'Caption' stores the text to display within the item.
  $rect <190,0,370,40>
  property string Caption = "Button";

  // The class 'ActionButton' implements a simple push button to start a certain \
  // action.
  // The button contains a text item that can be set with the property 'Caption'.
  // Each time the user has pressed the button a signal is sent to the slot method \
  // 'OnAction'.
  // The colors of the widget can be changed by using the properties 'ItemColor', \
  // 'ItemColorActive' and 'TextColor'.
  note legend Note
  {
    attr Bounds = <10,280,700,380>;
  }

  // The property 'ItemColor' defines the color of the widgets touchable member (knob). \
  // The property is used to assign a color independent from the current theme color.
  $rect <370,0,550,40>
  property color ItemColor = Flat::ColorOfTouch;

  $rect <370,40,550,80>
  onset ItemColor
  {
    /* store the new value */
    pure ItemColor = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  // The property 'TextColor' defines the color of the widgets text members. The \
  // property is used to assign a color independent from the current theme color.
  $rect <550,0,730,40>
  property color TextColor = Flat::ColorOfBackground;

  $rect <550,40,730,80>
  onset TextColor
  {
    /* store the new value */
    pure TextColor = value;

    /* ...and colorize the affected members of the widget */
    CaptionText.Color = value;

  }

  // The property 'ItemColorActive' defines the color of the widgets touchable member \
  // (knob) while it is touched by the user. The property is used to assign a color \
  // independent from the current theme color.
  $rect <370,90,550,130>
  property color ItemColorActive = Application::WidgetColor;

  $rect <370,130,550,170>
  onset ItemColorActive
  {
    /* store the new value */
    pure ItemColorActive = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }
}

// Toggle button widget with a flat design. The widget is used to switch a boolean \
// value on and off.
$rect <800,400,980,440>
$output false
class AToggleButton : Core::Group
{
  $rect <0,180,180,220>
  inherited property Bounds = <0,0,140,30>;

  $rect <0,260,180,300>
  inherited method UpdateLayout()
  {
    /* first make the super call to get the regular layouting */
    super( aSize );

    /* the arrangement of the components member depends on the height of the component */
    var int32 s = aSize.y;

    /* the button frame is always a square */
    Frame.Bounds = rect( 0, 0, s, s );

    /* the icon is lying on top of the frame */
    Image.Bounds = Frame.Bounds;

    /* the text item is on the right side */
    CaptionText.Bounds = rect( s + 10, 0, aSize.x, aSize.y );

  }

  $rect <0,220,180,260>
  inherited method UpdateViewState()
  {
    /* colorize frame and text, depending on current state of the view */
    if ( aState.contains( Core::ViewState[ Enabled ]))
    {
      if (( TouchHandler.Down && TouchHandler.Inside ) || pure Active )
      {
        Frame.Color = ItemColorActive;
        CaptionText.Color = ItemColorActive;
        Image.Color = IconColorActive;
      }
      else
      {
        Frame.Color = ItemColor;
        CaptionText.Color = ItemColor;
        Image.Color = IconColor;
      }
    }
    else
    {
      Frame.Color = Flat::ColorOfDisabled;
      CaptionText.Color = Flat::ColorOfDisabled;
      if ( pure Active )
        Image.Color = IconColorActive;
      else
        Image.Color = IconColor;
    }

  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <190,180,370,220>
  slot outletSlot
  {
    /* update the current state of the widget */
    if ( Outlet != null )
      Active = Outlet^;
  }

  // This internal slot method is used to receive the corresponding signals form \
  // the touch handler.
  $rect <190,220,370,260>
  slot enterLeaveSlot
  {
    InvalidateViewState();
  }

  // This internal slot method is used to receive the corresponding signals form \
  // the touch handler.
  $rect <190,260,370,300>
  slot pressReleaseSlot
  {
    /* releasing the finger outside the button area is ignored */
    if ( !TouchHandler.Down && TouchHandler.Inside )
    {
      Active = !Active;

      /* update the attached outlet */
      if ( Outlet != null )
        Outlet^ = Active;

      /* and inform other observers, that the outlet has changed its value */
      notifyobservers Outlet;

      /* inform the OnChange slot method */
      idlesignal OnChange;

      /* inform about the state change with the corresponding slot method */
      if ( Active )
        postsignal OnSwitchOn;
      else
        postsignal OnSwitchOff;
    }
  }

  $rect <190,130,370,170>
  onset Outlet
  {
    /* check if the new outlet differs from the currently used outlet */
    if ( pure Outlet == value )
      return;

    /* detach from the previous outlet */
    if ( pure Outlet != null )
      detachobserver outletSlot, pure Outlet;

    /* store the new outlet */
    pure Outlet = value;

    /* ... and attach to the new one */
    if ( value != null )
      attachobserver outletSlot, value;

    /* finally, update the current state of the widget by posting a signal to the outlet slot */
    if ( value != null )
      postsignal outletSlot;
  }

  $rect <190,40,370,80>
  onset Active
  {
    /* check if the given value differs from the current value */
    if ( pure Active == value )
      return;

    /* store the new value */
    pure Active = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // The property 'OnSwitchOff' can refer to a slot method, which will receive a \
  // signal as soon the button has changed its state to 'switched-off' (bistable \
  // buttons only). Thereupon the method's logic will be executed.
  $rect <370,220,550,260>
  property slot OnSwitchOff = null;

  // The property 'OnSwitchOn' can refer to a slot method, which will receive a signal \
  // as soon the button has changed its state to 'switched-on' (bistable buttons \
  // only). Thereupon the method's logic will be executed.
  $rect <370,180,550,220>
  property slot OnSwitchOn = null;

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // as soon the user has pressed the button. Thereupon the method's logic will be \
  // executed.
  $rect <370,260,550,300>
  property slot OnChange = null;

  // The property 'Outlet' provides an interface for the Controller-View model. In \
  // the Controller-View model, the widgets (views) and the application logic (controllers) \
  // are always kept apart. An automatism behind this model ensures, that widgets \
  // are notified automatically as soon as the affected controller has changed its \
  // state. On the other hand, user interactions on a widget cause the affected controller \
  // to execute the application logic. Usually, a controller is a simple Chora object \
  // containing several properties and the implementation of onget/onset method.
  // By assigning a property reference, Outlet establishes a connection between the \
  // widget and the controller object, the affected property belongs to. After this, \
  // the widget is able to read and modify the referred property in response to the \
  // user interactions. It is also able to adapt the widget appearance, if the value \
  // of the referred property has been modified by another widget or by the application \
  // logic itself.
  $rect <190,90,370,130>
  property ^bool Outlet = null;

  // The property 'Active' stores the current state of the button. As long as the \
  // property is 'false', the widget represents the status switched-off and should \
  // appear released. As long as the property is 'true', the widget represents the \
  // status switched-on and should appear pressed.
  $rect <190,0,370,40>
  property bool Active = false;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,30>;
    preset Point3 = <140,30>;
    preset Point2 = <140,0>;
    preset Point1 = <0,0>;
    preset OnLeave = enterLeaveSlot;
    preset OnEnter = enterLeaveSlot;
    preset OnRelease = pressReleaseSlot;
    preset OnPress = pressReleaseSlot;
  }

  $rect <20,20,160,60>
  object Views::Frame Frame
  {
    preset Bounds = <0,0,30,30>;
    preset Color = Flat::ColorOfTouch;
    preset Bitmap = Flat::FlatFrame;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,30,30>;
    preset Color = Flat::ColorOfBackground;
    preset FrameNumber = 19;
    preset Bitmap = Flat::FlatDemoIcons;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Bounds = <40,0,140,30>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Button";
    preset Font = Flat::FontM;
    preset Color = Flat::ColorOfTouch;
  }

  $rect <550,40,730,80>
  onset Icon
  {
    pure Icon    = value;
    Image.Bitmap = value;
  }

  // The property 'Icon' stores the bitmap to show in the left part of the button.
  $rect <550,0,730,40>
  property Resources::Bitmap Icon = Flat::FlatDemoIcons;

  // The property 'IconIndex' stores the frame number of the @Icon.
  $rect <370,90,550,130>
  property int32 IconIndex = 19;

  $rect <370,130,550,170>
  onset IconIndex
  {
    pure IconIndex = value;
    Image.FrameNumber = value;
  }

  $rect <370,40,550,80>
  onset Caption
  {
    pure Caption = value;
    CaptionText.String  = value;
  }

  // The property 'Caption' stores the text to display within the item.
  $rect <370,0,550,40>
  property string Caption = "Button";

  // The class 'ToggleButton' implements a switch widget with two states: 'on' or \
  // 'off'.
  // The property 'Active' represents the momentary state of the widget. A toggle \
  // button can be connected with a boolean 'Outlet' property to show the current \
  // value of the property and to change it.
  // The button contains a text item that can be set with the property 'Caption' \
  // and it can display an icon by using the properties 'Icon' and 'IconIndex'.
  // Additionally, a toggle button can trigger the slot methods 'OnChange', 'OnSwitchOn' \
  // and 'OnSwitchOff', whenever the user has changed the state of the widget.
  // The colors of the widget can be changed by using the properties 'ItemColor', \
  // 'ItemColorActive', 'IconColor' and 'IconColorActive'.
  note legend Note
  {
    attr Bounds = <10,320,830,500>;
  }

  // The property 'ItemColor' defines the color of the widgets touchable member (knob). \
  // The property is used to assign a color independent from the current theme color.
  $rect <730,0,910,40>
  property color ItemColor = Flat::ColorOfTouch;

  $rect <730,40,910,80>
  onset ItemColor
  {
    /* store the new value */
    pure ItemColor = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  // The property 'ItemColorActive' defines the color of the widgets touchable member \
  // (knob) while it is touched by the user. The property is used to assign a color \
  // independent from the current theme color.
  $rect <730,90,910,130>
  property color ItemColorActive = Application::WidgetColor;

  $rect <730,130,910,170>
  onset ItemColorActive
  {
    /* store the new value */
    pure ItemColorActive = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  // The property 'IconColorActive' defines the color of the widgets icon when it \
  // is activated. The property is used to assign a color independent from the current \
  // theme color.
  $rect <550,180,730,220>
  property color IconColorActive = Flat::ColorOfBackground;

  $rect <550,220,730,260>
  onset IconColorActive
  {
    /* store the new value */
    pure IconColorActive = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  // The property 'IconColor' defines the color of the widgets icon when it is not \
  // activated. The property is used to assign a color independent from the current \
  // theme color.
  $rect <550,90,730,130>
  property color IconColor = Flat::ColorOfBackground;

  $rect <550,130,730,170>
  onset IconColor
  {
    /* store the new value */
    pure IconColor = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }
}

// Horizontal slider widget with a flat design. The widget allows the user to change \
// a value by moving a thumb in horizontal direction.
$rect <800,440,980,480>
$output false
class AHorzSlider : Core::Group
{
  $rect <0,220,180,260>
  inherited method UpdateViewState()
  {
    var int32 pos = 0;
    var int32 textW = 0;

    /* ensure that the current set value and the given minimum and maximum values are valid */
    if (( MaxValue > MinValue ) && ( CurrentValue >= MinValue ) && ( CurrentValue <= MaxValue ))
    {
      /* calculate the center position of the thumb within the slider area */
      pos = ( Bounds.w - Thumb.Bounds.w ) * ( CurrentValue - MinValue ) / ( MaxValue - MinValue ) + Thumb.Bounds.w / 2;
    }

    /* calculate position of thumb */
    Thumb.Bounds.origin.x = pos - Thumb.Bounds.w / 2;

    /* arrange the rectangle according bar width */
    Rectangle.Bounds = rect( 0, Thumb.Bounds.y2 - pure SliderSize, Bounds.w, Thumb.Bounds.y2 );

    /* update the text items for current value */
    if ( pure ShowCurrent )
    {
      ThumbText.String = formatValueString( pure CurrentValue );
      MoveText.String = ThumbText.String;
    }

    /* update the text items for min/max values */
    if ( pure MinText != null )
      MinText.String = formatValueString( pure MinValue );
    if ( pure MaxText != null )
      MaxText.String = formatValueString( pure MaxValue );

    /* calculate position of thumb text item */
    textW = ThumbText.GetContentArea().w;
    ThumbText.Bounds.origin.x = pos - textW / 2;

    if ( ThumbText.Bounds.origin.x < 0 )
      ThumbText.Bounds.origin.x = 0;
    else if ( ThumbText.Bounds.origin.x > Bounds.w - textW )
      ThumbText.Bounds.origin.x = Bounds.w - textW;

    /* calculate position of move text item */
    textW = MoveText.GetContentArea().w;
    if ( pos < Bounds.w / 2 )
      MoveText.Bounds.origin.x = pos + Thumb.Bounds.w / 2 + 5;
    else
      MoveText.Bounds.origin.x = pos - Thumb.Bounds.w / 2 - 5 - textW;

    /* calculate position of touch handler a bit larger than the thumb */
    SimpleTouchHandler.Point1 = point( Thumb.Bounds.x1 - 10, Thumb.Bounds.y1 - 10 );
    SimpleTouchHandler.Point2 = point( Thumb.Bounds.x1 - 10, Thumb.Bounds.y2 + 10 );
    SimpleTouchHandler.Point3 = point( Thumb.Bounds.x2 + 10, Thumb.Bounds.y2 + 10 );
    SimpleTouchHandler.Point4 = point( Thumb.Bounds.x2 + 10, Thumb.Bounds.y1 - 10 );

    /* colorize thumb and text, depending on current state of the view */
    if ( aState.contains( Core::ViewState[ Enabled ]))
    {
      ThumbText.Color = TextColor;
      if ( SimpleTouchHandler.Down )
      {
        ThumbText.Visible = false;
        MoveText.Visible = pure ShowCurrent;
        Thumb.Color = ItemColorActive;
      }
      else
      {
        ThumbText.Visible = pure ShowCurrent;
        MoveText.Visible = false;
        Thumb.Color = ItemColor;
      }
    }
    else
    {
      ThumbText.Visible = true;
      MoveText.Visible = false;
      Thumb.Color = Flat::ColorOfDisabled;
      ThumbText.Color = Flat::ColorOfDisabled;
    }

  }

  $rect <0,180,180,220>
  inherited property Bounds = <0,0,160,70>;

  $rect <0,260,180,300>
  inherited method UpdateLayout()
  {
    /* first make the super call to get the regular layouting */
    super( aSize );

    /* the arrangement of the components member depends on the size of the thumb */
    var int32 s = Thumb.Bitmap.FrameSize.y;

    /* arrange the rectangle */
    Rectangle.Bounds = rect( 0, aSize.y - s - pure SliderSize, aSize.x, aSize.y - s );

    /* arrange the thumb */
    Thumb.Bounds.origin.y = aSize.y - 2 * s;

    /* arrange the thumb text and the move text */
    ThumbText.Bounds.y1 = aSize.y - 3 * s - 2;
    ThumbText.Bounds.y2 = aSize.y - 2 * s;
    MoveText.Bounds.y1 = 0;
    MoveText.Bounds.y2 = Rectangle.Bounds.origin.y;




  }

  // The property 'MinValue' defines the lower boundary of the widgets value range.
  $rect <370,0,550,40>
  property int32 MinValue = 0;

  $rect <370,40,550,80>
  onset MinValue
  {
    /* check if the given value differs from the current value */
    if ( pure MinValue == value )
      return;

    /* store the new value */
    pure MinValue = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // The property 'MaxValue' defines the upper boundary of the widgets value range.
  $rect <550,0,730,40>
  property int32 MaxValue = 100;

  $rect <550,40,730,80>
  onset MaxValue
  {
    /* check if the given value differs from the current value */
    if ( pure MaxValue == value )
      return;

    /* store the new value */
    pure MaxValue = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // The property 'CurrentValue' stores the momentary value of the widget. The value \
  // is limited automatically to the range from @MinValue to @MaxValue.
  $rect <190,0,370,40>
  property int32 CurrentValue = 50;

  $rect <190,40,370,80>
  onset CurrentValue
  {
    /* limit the given value to the range between MinValue and MaxValue */
    if ( value < MinValue )
      value = MinValue;
    if ( value > MaxValue )
      value = MaxValue;

    /* check if the given value differs from the current value */
    if ( pure CurrentValue == value )
      return;

    /* store the new value */
    pure CurrentValue = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // This variable stores the Value at the beginning of the user interaction.
  $rect <190,340,370,380>
  var int32 startValue = 0;

  // This internal slot method is used to receive the corresponding signals form \
  // the touch handler.
  $rect <190,220,370,260>
  slot onPressSlot
  {
    /* The user interaction begins. Force the widget to highlight itself. */
    InvalidateViewState();
    startValue = CurrentValue;
  }

  // This internal slot method is used to receive the corresponding signals form \
  // the touch handler.
  $rect <190,260,370,300>
  slot onDragSlot
  {
    var int32 oldValue = CurrentValue;
    var int32 ofs = SimpleTouchHandler.CurrentPos.x - SimpleTouchHandler.HittingPos.x;

    /* ensure that the current set value and the given minimum and maximum values are valid */
    if (( MaxValue > MinValue ) && ( CurrentValue >= MinValue ) && ( CurrentValue <= MaxValue ))
    {
      /* calculate the center position of the thumb within the slider area */
      ofs = ofs * ( MaxValue - MinValue ) / ( Bounds.w - Thumb.Bounds.w );
    }
    else
      ofs = 0;

    /* change the value */
    CurrentValue = startValue + ofs;

    /* inform others about the changed value */
    if ( CurrentValue != oldValue )
    {
      /* update the attached outlet, if there is one... */
      if (  Outlet != null )
        Outlet^ = CurrentValue;

      /* ... and inform other observers, that the outlet has changed its value */
      notifyobservers Outlet;

      /* inform the OnChange slot method */
      idlesignal OnChange;
    }

  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <190,180,370,220>
  slot outletSlot
  {
    /* update the current state of the widget */
    if ( Outlet != null )
      CurrentValue = Outlet^;
  }

  $rect <190,130,370,170>
  onset Outlet
  {
    /* check if the new outlet differs from the currently used outlet */
    if ( pure Outlet == value )
      return;

    /* detach from the previous outlet */
    detachobserver outletSlot, pure Outlet;

    /* store the new outlet */
    pure Outlet = value;

    /* ... and attach to the new one */
    attachobserver outletSlot, value;

    /* finally, update the current state of the widget by posting a signal to the outlet slot */
    if ( value != null )
      postsignal outletSlot;
  }

  // The property 'Outlet' provides an interface for the Controller-View model. In \
  // the Controller-View model, the widgets (views) and the application logic (controllers) \
  // are always kept apart. An automatism behind this model ensures, that widgets \
  // are notified automatically as soon as the affected controller has changed its \
  // state. On the other hand, user interactions on a widget cause the affected controller \
  // to execute the application logic. Usually, a controller is a simple Chora object \
  // containing several properties and the implementation of onget/onset method.
  // By assigning a property reference, Outlet establishes a connection between the \
  // widget and the controller object, the affected property belongs to. After this, \
  // the widget is able to read and modify the referred property in response to the \
  // user interactions. It is also able to adapt the widget appearance, if the value \
  // of the referred property has been modified by another widget or by the application \
  // logic itself.
  $rect <190,90,370,130>
  property ^int32 Outlet = null;

  // The property 'OnApply' can refer to a slot method, which will receive a signal \
  // when the user has released the slider. Thereupon the method's logic will be \
  // executed.
  $rect <370,300,550,340>
  property slot OnApply = null;

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // each time the user has changed the value of the slider. Thereupon the method's \
  // logic will be executed.
  $rect <370,260,550,300>
  property slot OnChange = null;

  // This internal slot method is used to receive the corresponding signals form \
  // the touch handler.
  $rect <190,300,370,340>
  slot onReleaseSlot
  {
    /* The user interaction terminates. Force the widget to de-highlight itself. */
    InvalidateViewState();

    /* inform about the new state */
    postsignal OnApply;

  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <60,72>;
    preset Point3 = <126,72>;
    preset Point2 = <126,40>;
    preset Point1 = <60,40>;
    preset OnDrag = onDragSlot;
    preset OnRelease = onReleaseSlot;
    preset OnPress = onPressSlot;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <0,34,160,40>;
    preset Color = Flat::ColorOfBody;
  }

  $rect <20,20,160,60>
  object Views::Image Thumb
  {
    preset Layout = Core::Layout[];
    preset Bounds = <70,20,90,40>;
    preset AutoSize = true;
    preset Color = Flat::ColorOfTouch;
    preset Alignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset Bitmap = Flat::FlatKnobs;
  }

  $rect <20,20,160,60>
  object Views::Text ThumbText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToTop];
    preset Bounds = <60,0,100,30>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertBottom];
    preset String = "50";
    preset Font = Flat::FontS;
    preset Color = Flat::ColorOfTouch;
  }

  $rect <20,20,160,60>
  object Views::Text MoveText
  {
    preset Bounds = <0,0,100,34>;
    preset AutoSize = true;
    preset String = "50";
    preset Font = Flat::FontL;
    preset Color = Flat::ColorOfTouch;
  }

  // The property 'ShowCurrent' controls the visibility of the text items displaying \
  // the current value.
  $rect <370,180,550,220>
  property bool ShowCurrent = true;

  $rect <370,220,550,260>
  onset ShowCurrent
  {
    /* store the new value */
    pure ShowCurrent = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  // The property 'DotPosition' stores the index of the digit where the dot is shown. \
  // In case that 'DotPosition' is zero, the dot disappears.
  $rect <370,90,550,130>
  property int32 DotPosition = 0;

  $rect <370,130,550,170>
  onset DotPosition
  {
    /* check if the given value differs from the current value */
    if ( pure DotPosition == value )
      return;

    /* check limits of the given value */
    if ( value < 0 )
      value = 0;
    if ( value > 3 )
      value = 3;

    /* store the new value */
    pure DotPosition = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // The property 'Divisor' stores the ratio for the display value.
  $rect <550,90,730,130>
  property int32 Divisor = 1;

  $rect <550,130,730,170>
  onset Divisor
  {
    /* check if the given value differs from the current value */
    if ( pure Divisor == value )
      return;

    /* check limits of the given value */
    if ( value < 1 )
      value = 1;
    if ( value > 1000 )
      value = 1000;

    /* store the new value */
    pure Divisor = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // Method to format a string based on the given aValue and the current @DotPosition \
  // and @Divisor.
  $rect <0,300,180,340>
  method string formatValueString( arg int32 aValue )
  {
    /* calculate the value to display */
    var int32 val = aValue / pure Divisor;
    var int32 abs = val;
    if ( val < 0 )
      abs = -val;

    /* format a string with decimal point if needed */
    if ( pure DotPosition == 1 )
      return string( val / 10, 1 ) + "." + string( abs % 10, 1 );
    else if ( pure DotPosition == 2 )
      return string( val / 100, 1 ) + "." + string( abs % 100, 2 );
    else if ( pure DotPosition == 3 )
      return string( val / 1000, 1 ) + "." + string( abs % 1000, 3 );

    return string( val );
  }

  // The property 'MinText' can refer to a Flat::MinMaxText item, which receives \
  // the current @MinValue of the widget as formatted text.
  $rect <730,90,910,130>
  property Flat::MinMaxText MinText = null;

  $rect <730,130,910,170>
  onset MinText
  {
    /* store the new value */
    pure MinText = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  // The property 'MaxText' can refer to a Flat::MinMaxText item, which receives \
  // the current @MaxValue of the widget as formatted text.
  $rect <730,180,910,220>
  property Flat::MinMaxText MaxText = null;

  $rect <730,220,910,260>
  onset MaxText
  {
    /* store the new value */
    pure MaxText = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  // The property 'SliderSize' defines the height of the filled rectangle in pixel.
  $rect <550,180,730,220>
  property int32 SliderSize = Flat::SliderSize;

  $rect <550,220,730,260>
  onset SliderSize
  {
    /* check if the given value differs from the current value */
    if ( pure SliderSize == value )
      return;

    /* check limits of the given value */
    if ( value < 0 )
      value = 0;

    /* store the new value */
    pure SliderSize = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // The class 'HorzSlider' implements a horizontal slider widget, that is used to \
  // change a value by moving a thumb.
  // The property 'CurrentValue' represents the momentary value of the widget and \
  // corresponds to the position of the thumb. The supported value range of the slider \
  // can be defined by setting the properties 'MinValue' and 'MaxValue'.
  // A slider can be connected with an Int32 'Outlet' property to show the current \
  // value of the property and to change it by moving the thumb.
  // Additionally, a slider can trigger the slot methods 'OnChange' and 'OnApply' \
  // as soon as the user has changed the thumb position or released the thumb.
  // The current value of the slider is shown within a moving text item. The properties \
  // 'DotPosition' and 'Divisor' can be used to configure the text display. If the \
  // min/max values should be displayed within separate text items, the slider can \
  // be connected with MinMaxText widgets via the properties 'MinText' and 'MaxText'.
  // The colors of the widget can be changed by using the properties 'ItemColor', \
  // 'ItemColorActive', 'BackColor' and 'TextColor'.
  note legend Note
  {
    attr Bounds = <10,390,950,610>;
  }

  // The property 'BackColor' defines the background color of the widget. The property \
  // is used to assign a color independent from the current theme color.
  $rect <910,180,1090,220>
  property color BackColor = Flat::ColorOfBody;

  $rect <910,220,1090,260>
  onset BackColor
  {
    /* store the new value */
    pure BackColor = value;

    /* ...and colorize the affected members of the widget */
    Rectangle.Color = value;



  }

  // The property 'ItemColor' defines the color of the widgets touchable member (knob). \
  // The property is used to assign a color independent from the current theme color.
  $rect <910,0,1090,40>
  property color ItemColor = Flat::ColorOfTouch;

  $rect <910,40,1090,80>
  onset ItemColor
  {
    /* store the new value */
    pure ItemColor = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  // The property 'TextColor' defines the color of the widgets text members. The \
  // property is used to assign a color independent from the current theme color.
  $rect <910,270,1090,310>
  property color TextColor = Flat::ColorOfTouch;

  $rect <910,310,1090,350>
  onset TextColor
  {
    /* store the new value */
    pure TextColor = value;

    /* colorize part of the affected members of the widget */
    MoveText.Color = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  // The property 'ItemColorActive' defines the color of the widgets touchable member \
  // (knob) while it is touched by the user. The property is used to assign a color \
  // independent from the current theme color.
  $rect <910,90,1090,130>
  property color ItemColorActive = Application::WidgetColor;

  $rect <910,130,1090,170>
  onset ItemColorActive
  {
    /* store the new value */
    pure ItemColorActive = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  $reorder UpdateViewState 44
}

// Indicator widget with a flat design. The widget is used to display a boolean value.
$rect <800,480,980,520>
$output false
class AIndicator : Core::Group
{
  $rect <0,90,180,130>
  inherited property Bounds = <0,0,30,30>;

  $rect <0,130,180,170>
  inherited method UpdateViewState()
  {
    aState;

    /* colorize frame and icon, depending on current state of the view */
    if ( Active )
    {
      Frame.Color = BackColorActive;
      Image.Color = IconColorActive;
    }
    else
    {
      Frame.Color = BackColor;
      Image.Color = IconColor;
    }

  }

  $rect <20,20,160,60>
  object Views::Rectangle Frame
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,30,30>;
    preset Color = Flat::ColorOfBody;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,30,30>;
    preset Color = Flat::ColorOfBackground;
    preset FrameNumber = 19;
    preset Bitmap = Flat::FlatDemoIcons;
  }

  $rect <370,40,550,80>
  onset Icon
  {
    /* store the new value */
    pure Icon    = value;

    /* and assign it to the image */
    Image.Bitmap = value;
  }

  // The property 'Icon' stores the bitmap to show in the left part of the button.
  $rect <370,0,550,40>
  property Resources::Bitmap Icon = Flat::FlatDemoIcons;

  // The property 'IconIndex' stores the frame number of the @Icon.
  $rect <550,0,730,40>
  property int32 IconIndex = 19;

  $rect <550,40,730,80>
  onset IconIndex
  {
    /* store the new value */
    pure IconIndex = value;

    /* and select the corresponding frame number */
    Image.FrameNumber = value;
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <190,180,370,220>
  slot outletSlot
  {
    /* update the current state of the widget */
    if ( Outlet != null )
      Active = Outlet^;
  }

  $rect <190,130,370,170>
  onset Outlet
  {
    /* check if the new outlet differs from the currently used outlet */
    if ( pure Outlet == value )
      return;

    /* detach from the previous outlet */
    if ( pure Outlet != null )
      detachobserver outletSlot, pure Outlet;

    /* store the new outlet */
    pure Outlet = value;

    /* ... and attach to the new one */
    if ( value != null )
      attachobserver outletSlot, value;

    /* finally, update the current state of the widget by posting a signal to the outlet slot */
    if ( value != null )
      postsignal outletSlot;
  }

  // The property 'Outlet' provides an interface for the Controller-View model. In \
  // the Controller-View model, the widgets (views) and the application logic (controllers) \
  // are always kept apart. An automatism behind this model ensures, that widgets \
  // are notified automatically as soon as the affected controller has changed its \
  // state. On the other hand, user interactions on a widget cause the affected controller \
  // to execute the application logic. Usually, a controller is a simple Chora object \
  // containing several properties and the implementation of onget/onset method.
  // By assigning a property reference, Outlet establishes a connection between the \
  // widget and the controller object, the affected property belongs to. After this, \
  // the widget is able to read and modify the referred property in response to the \
  // user interactions. It is also able to adapt the widget appearance, if the value \
  // of the referred property has been modified by another widget or by the application \
  // logic itself.
  $rect <190,90,370,130>
  property ^bool Outlet = null;

  $rect <190,40,370,80>
  onset Active
  {
    /* check if the given value differs from the current value */
    if ( pure Active == value )
      return;

    /* store the new value */
    pure Active = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // The property 'Active' stores the current state of the indicator. As long as \
  // the property is 'false', the widget should appear 'dark'. As long as the property \
  // is 'true', the widget should appear illuminated.
  $rect <190,0,370,40>
  property bool Active = false;

  // The class 'Indicator' implements a widget to display a boolean value.
  // The widget can be connected with a boolean 'Outlet' property in order to illustrate \
  // the current state.
  // The displayed icon can be configured via the properties 'Icon' and 'IconIndex'.
  // Additionally, the used colors can be configured individually: for the state \
  // 'inactive' the colors 'BackColor' and 'IconColor' are used, for the state 'active' \
  // the colors 'BackColorActive' and 'IconColorActive' are used.
  note legend Note
  {
    attr Bounds = <10,270,720,390>;
  }

  // The property 'BackColorActive' defines the color of the widget when it is activated. \
  // The property is used to assign a color independent from the current theme color.
  $rect <370,180,550,220>
  property color BackColorActive = Application::WidgetColor;

  $rect <370,220,550,260>
  onset BackColorActive
  {
    /* store the new value */
    pure BackColorActive = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // The property 'BackColor' defines the color of the widget when it is not activated. \
  // The property is used to assign a color independent from the current theme color.
  $rect <370,90,550,130>
  property color BackColor = Flat::ColorOfBody;

  $rect <370,130,550,170>
  onset BackColor
  {
    /* store the new value */
    pure BackColor = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // The property 'IconColorActive' defines the color of the widgets icon when it \
  // is activated. The property is used to assign a color independent from the current \
  // theme color.
  $rect <550,180,730,220>
  property color IconColorActive = Flat::ColorOfBody;

  $rect <550,220,730,260>
  onset IconColorActive
  {
    /* store the new value */
    pure IconColorActive = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  // The property 'IconColor' defines the color of the widgets icon when it is not \
  // activated. The property is used to assign a color independent from the current \
  // theme color.
  $rect <550,90,730,130>
  property color IconColor = Flat::ColorOfDisabled;

  $rect <550,130,730,170>
  onset IconColor
  {
    /* store the new value */
    pure IconColor = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }
}
